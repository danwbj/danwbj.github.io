<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOS7安装配置Nginx]]></title>
    <url>%2F2018%2F04%2F15%2FCentOS7%E9%83%A8%E7%BD%B2Nginx%2F</url>
    <content type="text"><![CDATA[安装 安装nginx依赖包 123yum install opensslyum install zlibyum install pcre Nginx依赖项 1rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装nginx 1yum install nginx 启动nginx 123service start nginx或者systemctl start nginx 配置主配置文件：/etc/nginx/conf.d/nginx.conf在主配置的include处可以修改自己的配置文件路径 12345678910111213141516171819202122232425262728293031323334user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; #include /etc/nginx/conf.d/*.conf; // 默认配置文件位置; include /root/nginx/conf/*.conf; // 修改为自己的路径;&#125;]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>linux</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建node的GraphQL服务端]]></title>
    <url>%2F2018%2F04%2F15%2F%E6%90%AD%E5%BB%BAnode%E7%9A%84GraphQL%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[GraphQL和传统的REST API相比查询更加灵活，GraphQL 简单来说就是：取哪些数据是由client来决定，GraphQL 中，client 直接对 server说想要什么数据，server负责精确的返回目标数据，以nodejs为例搭建一个简单地服务端。 GraphQL工作的大致流程 描述你的数据 12345type Project &#123; name: String tagline: String contributors: [User]&#125; 请求你所要的数据 12345&#123; project(name: &quot;GraphQL&quot;) &#123; tagline &#125;&#125; 得到可预测的结果 12345&#123; &quot;project&quot;: &#123; &quot;tagline&quot;: &quot;A query language for APIs&quot; &#125;&#125; 需求分析设计用户可以发表作品，可以对其他用户发表的作品投票 使用apollo-server-express初始化一个服务创建目录初始化项目123mkdir graphql_node_democd graphql_node_demonpm init 安装依赖1npm i express body-parser apollo-server-express graphql graphql-tools --save 在根目录下创建启动文件index.js1234567891011121314151617181920212223242526272829const express = require('express');const bodyParser = require('body-parser');const &#123; graphqlExpress, graphiqlExpress &#125; = require('apollo-server-express');const &#123; createServer &#125; = require('http');const PORT = process.env.PORT || 3000;const NODE_ENV = process.env.NODE_ENV || 'development'const start = async () =&gt; &#123; var app = express(); const buildOptions = async (req, res) =&gt; &#123; return &#123; context: &#123;&#125; &#125;; &#125;; app.use('/graphql', bodyParser.json(), graphqlExpress(buildOptions)); app.use('/graphiql', graphiqlExpress(&#123; endpointURL: '/graphql', &#125;)); const server = createServer(app); server.listen(PORT, () =&gt; &#123; console.log(`fmlp.$&#123;NODE_ENV&#125; GraphQL server running on port $&#123;PORT&#125;`) &#125;);&#125;;start(); 现在可以启动服务尝试一下1node index.js 在浏览器访问http://localhost:3000/graphiql 可以看到会报错，是因为还没有添加schema 增加schema创建一个schema文件夹，并在文件夹里面抽创建两个文件，index.js、resolvers.jsindex.js里面定义我们的type，也就是描述数据，resolvers.js定义对返回数据的解析函数1234mkdir schemacd schematouch index.jstouch resolvers.js schema/index.js文件中我们定义三个type1234567891011121314151617181920const &#123;makeExecutableSchema&#125; = require('graphql-tools');const resolvers = require('./resolvers');// 在这里定义所有的类型const typeDefs = ` type Link &#123; id: ID! url: String! description: String! postedById:String! postedBy: User &#125; type Query &#123; allLinks: [Link!]! //定义了Query类型的查询，里面有一个查询所有Links,他的返回值是一个Link类型的数组 &#125; type User &#123; id: ID! name: String! email: String &#125;`; schema/resolvers.js文件中去执行查询并且返回客户端12345678910111213141516let links = [ &#123; id: 1, url: "http://url1", description: "link1", postedById:"userid1" &#125;]module.exports = &#123; Query: &#123; allLinks: (_, data) =&gt; &#123; return links &#125;, &#125;&#125;; ok 启动服务，刷新浏览器成功输入我们想要的查询 123456789//此处需要哪些字段写哪些字段&#123; allLinks &#123; id url description postedById &#125;&#125; 就可以返回123456789101112&#123; "data": &#123; "allLinks": [ &#123; "id": "1", "url": "http://url1", "description": "link1", "postedById": "userid1" &#125; ] &#125;&#125; 这就是一个简单的graphql查询另外Link中有一个字段postedBy是一个User类型，我们可以在resolvers.js中增加对Link中的User字段的解析，使Link列表可以返回每个Link是哪个用户发表的，这样实现了原始的关联查询在resolvers.js中增加以下代码：12345678910Link: &#123; postedBy: (&#123; postedById &#125;, data) =&gt; &#123; //此处需要根绝postedById查询数据库返回对用的user return &#123; id: postedById, name: "zhangsan", email: "zhangsan@11.com" &#125; &#125; &#125;, 由于我们没有对接真实的数据库，所以此处省略数据库查询的过程刷新浏览器现在的查询就可以是这样的12345678910111213&#123; allLinks &#123; id url description postedById postedBy&#123; id name email &#125; &#125;&#125; 返回值也变化了1234567891011121314151617&#123; "data": &#123; "allLinks": [ &#123; "id": "1", "url": "http://url1", "description": "link1", "postedById": "userid1", "postedBy": &#123; "id": "userid1", "name": "zhangsan", "email": "zhangsan@11.com" &#125; &#125; ] &#125;&#125; 这里只是实现了简单地查询操作，另外还有一些创建编辑删除的操作是需要用到Mutation类型来实现，具体不写出来，直接看github源码https://github.com/danwbj/graphql-server-apollo.git]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux环境下安装node]]></title>
    <url>%2F2018%2F04%2F14%2FLinux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85node%2F</url>
    <content type="text"><![CDATA[下载1wget https://npm.taobao.org/mirrors/node/v8.9.3/node-v8.9.3-linux-x64.tar.xz 解压解压后的文件需要保留，压缩文件可以删除1tar -xzvf node-v8.9.3-linux-x64.tar.gz 创建软连接12ln -s /node-v8.9.3-linux-x64/bin/node /usr/local/bin/nodeln -s /node-v8.9.3-linux-x64/bin/npm/usr/local/bin/npm 测试安装是否成功12node -v 出现版本号即安装成功npm -v 出现版本号即安装成功 ok!]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令学习笔记]]></title>
    <url>%2F2018%2F04%2F10%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现插入排序算法]]></title>
    <url>%2F2018%2F03%2F22%2Fjs%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原理：从下标1开始，current=array[i],对数组的前i-1项进行检查，如果存在大于current值，将此值往后移，赋值给下一项 以下是js代码的实现：12345678910111213141516function sort(arr) &#123; for (let i = 1; i &lt; arr.length; i++)&#123; let current = arr[i] var index = i;//记录要被插入的下标 for (let j = i-1; j &gt;= 0; j--)&#123; if (current &lt; arr[j]) &#123; arr[j + 1] = arr[j] index = j &#125; &#125; arr[index] = current &#125; return arr&#125;let arr = [34,8,64,51,32,21]console.log(sort(arr))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现冒泡排序算法]]></title>
    <url>%2F2018%2F03%2F22%2Fjs%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原理：将前后两个数进行比较，较大或者较小的往后放例如：let numbers={ 1,5,3,6,4,9,8,0,7,2}第一轮比较：第一次比较：1，5，3，6，4，9，8，0，7，2第一个数不大于第二个数，不调换位置 第二次比较：1，3，5，6，4，9，8，0，7，2第二个数大于第三个数，调换位置 第三次比较：1，3，5，6，4，9，8，0，7，2 第三个数不大于第四个数，不调换位置 第四次比较：1，3，5，4，6，9，8，0，7，2 第四个数大于第五个数，调换位置...以此类推 第九次比较：1，3，5，4，6，8，0，7，2，9第九个数大于第十个数，调换位置 第二轮比较：比较次数8次 第三轮比较：比较次数7次...以此类推 第九轮比较1次从上面的分析我们可以看出我们排10个数需要比较九轮，每一轮比较由9次递减到1次 以下是js代码的实现：1234567891011121314var arr = [2, 10, 3, 4, 1, 7, 5, 6, 9, 8]function sort(arr) &#123; for (let i = 0; i &lt; arr.length-1; i++)&#123; for (let j = 0; j &lt; arr.length-1-i; j++)&#123; let temp = arr[j] if (arr[j] &gt; arr[j + 1]) &#123; arr[j] = arr[j + 1] arr[j+1] = temp &#125; &#125; &#125;&#125;sort(arr)console.log(arr)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker常用命令整理]]></title>
    <url>%2F2018%2F03%2F16%2Fdocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[docker信息12345# 查看docker版本$ docker version# 查看docker系统信息$ docker info 镜像1234567891011121314151617181920212223242526# 查看镜像列表$ docker images# 删除镜像$ docker rmi name/id# 基于Dockerfile文件build镜像$ docker build [options] 镜像名 . 注意： .代表Dockerfile文件在当前路径 -t 为容器重新分配一个伪终端# 创建一个新的容器并跑一个镜像docker run [options] image -i 以交互模式运行 -t 为容器重新分配一个伪终端 -d 运行到后台 -p 80:80 端口映射 --name xxx 为容器指定一个名称# 保存images为一个tar文件$ docker save image_name -o name.tar或者$ docker save image_name &gt; name.tar#从一个tar文件加载images$ docker load &lt; name.tar 容器12345678910111213141516# 显示正在运行的容器$ docker ps -a 显示所有容器，包含不是运行中的容器# 停止运行中的容器$ docker stop 容器name/id#删除容器$ docker rm 容器name/id#进入到某个容器中$ docker exec -it 容器name/id /bin/bash #通过差异性创建一个新的image$ docker commit 容器id 新的镜像名eg: docker commit bf2eff778794 dandanwu/testimage:v2 Dockerfile编写DockerFile分为四部分组成：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令123456789101112131415161718192021222324252627282930313233343536373839404142#第一行必须指令基于的基础镜像FROM ubutu#维护者信息MAINTAINER docker_user docker_user@mail.com#使用哪个用户跑container USER#将文件&lt;src&gt;拷贝到container的文件系统对应的路径&lt;dest&gt;COPY file.js /home/file.js#将文件&lt;src&gt;拷贝到container的文件系统对应的路径&lt;dest&gt;ADD file.js /home/file.js#在终端中执行命令RUN apt-get update &amp;&amp; apt-get install -y ngnix RUN echo "\ndaemon off;"&gt;&gt;/etc/ngnix/nignix.conf#container内部服务开启的端口，主机上要用还得在启动container时，做host-container的端口映射EXPOSE 8017#设置环境变量ENV#切换目录用，可以多次切换(相当于cd命令)，对RUN,CMD,ENTRYPOINT生效WORKDIR ../#可以将本地文件夹或者其他container的文件夹挂载到container中。VOLUME#容器启动时执行指令#一个Dockerfile中只能有一条CMD命令，多条则只执行最后一条CMD#可替换性：当docker run command的命令匹配到CMD command时，会替换CMD执行的命令。CMD /usr/sbin/ngnix#需要执行多条命令的时候可以像下边这样写CMD [ "cmd1", "cmd2", "cmd3" ]#container启动时执行的命令，但是一个Dockerfile中只能有一条ENTRYPOINT命令，如果多条，则只执行最后一条#ENTRYPOINT没有CMD的可替换特性ENTRYPOINT /usr/sbin/ngnix]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js对象引用赋值引发数据可变的解决方案]]></title>
    <url>%2F2018%2F03%2F01%2Fjs%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E8%B5%8B%E5%80%BC%E5%BC%95%E5%8F%91%E6%95%B0%E6%8D%AE%E5%8F%AF%E5%8F%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[js赋值（引用赋值）12345678910111213141516171819const student1 = &#123; school: 'Baidu', name: 'HOU Ce', birthdate: '1995-12-15',&#125;const changeStudent = (student, newName, newBday) =&gt; &#123; const newStudent = student; newStudent.name = newName; newStudent.birthdate = newBday; return newStudent;&#125;const student2 = changeStudent(student1, 'YAN Haijing', '1990-11-10');// both students will have the name propertiesconsole.log(student1, student2);// Object &#123;school: "Baidu", name: "YAN Haijing", birthdate: "1990-11-10"&#125; // Object &#123;school: "Baidu", name: "YAN Haijing", birthdate: "1990-11-10"&#125; 创建了一个新的对象student2，但是老的对象student1也被改动了 深拷贝与浅拷贝的区别以Object.assign(浅拷贝)为列：123456var obj1 = &#123; a: 0, b: &#123; c: 0 &#125; &#125;var obj2 = Object.assign(&#123;&#125;, obj1)obj2.a = 1obj2.b.c = 1console.log(obj1) //&#123; a: 0, b: &#123; c: 1 &#125; &#125;console.log(obj2) //&#123; a: 1, b: &#123; c: 1 &#125; 为什么改变属性a不是指向同一个引用，而b.c指向了同一个引用?因为b不是简单地数据类型，Object.assign拷贝的时候是浅拷贝，只复制了{ c: 0 }的引用变量b,而a:1是简单类型，拷贝的时候拷贝的是值，所以当obj2.b.c改变的时候，因为obj1.b和obj2.b指向的是同一个内存地址，所以obj1.b.c的值也发生了改变。如果是深拷贝obj1.b.c的值就不会因为obj2.b.c改变而改变 解决方案（创建不可变数据）使用ES6当中的解构赋值(浅拷贝，而不是深拷贝)1234567891011121314const changeStudent = (student, newName, newBday) =&gt; &#123; return &#123; ...student, // 使用解构 name: newName, // 覆盖name属性 birthdate: newBday // 覆盖birthdate属性 &#125;&#125;const student2 = changeStudent(student1, 'YAN Haijing', '1990-11-10');// both students will have the name propertiesconsole.log(student1, student2);// Object &#123;school: "Baidu", name: "HOU Ce", birthdate: "1995-12-15"&#125; // Object &#123;school: "Baidu", name: "YAN Haijing", birthdate: "1990-11-10"&#125; Objects.assign(浅拷贝，而不是深拷贝)12345const changeStudent = (student, newName, newBday) =&gt; Object.assign(&#123;&#125;, student, &#123;name: newName, birthdate: newBday&#125;)const student2 = changeStudent(student1, 'YAN Haijing', '1990-11-10');console.log(student1, student2); 使用第三方库 比如lodash中的merge函数 注意：对于数组来说，它里面的 .map, .filter或者.reduce函数不会改变原数组，而是产生并返回一个新数组。这和纯函数的思想不谋而合。 原文连接：https://juejin.im/post/58d0ff6f1b69e6006b8fd4e9]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>引用赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript的变量函数提升总结]]></title>
    <url>%2F2018%2F03%2F01%2Fjavascript%E7%9A%84%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[首先对比三段代码：12var v='Hello World';alert(v); //Hello World 1234var v='Hello World';(function()&#123; alert(v);&#125;)()//Hello World 12345var v='Hello World';(function()&#123; alert(v); var v='I love you';&#125;)()//undefined javascript作用域JavaScript是函数级作用域(function-level scope)，并没有块级作用域,因此在代码块中并不会创建一个新的作用域。只有函数才会创建新的作用域，这样块里面的变量会影响到外部作用域，比如if语句：1234567var x = 1;console.log(x); // 1if (true) &#123; var x = 2; console.log(x); //2&#125; console.log(x);// 2 解决方案：在函数中创建一个临时的作用域，请像下面这样做12345678910function foo() &#123; var x = 1; if (x) &#123; (function () &#123; var x = 2; // some other code &#125;()); &#125; // x is still 1.&#125; 变量提升变量提升 只是提升变量的声明，并不会把赋值也提升上来。我们定义三个变量： 12345(function()&#123; var a='One'; var b='Two'; var c='Three';&#125;)() 实际上它是这样子的：123456(function()&#123; var a,b,c; a='One'; b='Two'; c='Three';&#125;)() 函数提升js中函数的定义有两种，函数声明方式和函数表达式方式，需要注意的是只有函数声明会被提升 函数声明方式提升【成功】 1234567function myTest()&#123; foo(); function foo()&#123; alert("我来自 foo"); &#125;&#125;myTest(); 函数表达式方式提升【失败】 1234567function myTest()&#123; foo(); var foo =function foo()&#123; alert("我来自 foo"); &#125;&#125;myTest(); 原文：http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>变量函数提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输出1-100之间的素数]]></title>
    <url>%2F2018%2F02%2F28%2F%E8%BE%93%E5%87%BA1-100%E4%B9%8B%E9%97%B4%E7%9A%84%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[素数：除了1和它本身外没有其他因数，即，除了1和它本身外不能被其他数整除1—不是素数2—最小的素数3—2（判断是否能被2整除）4—2，3（判断是否能被2,3整除）5—2，3，4（判断是否能被2,3,4整除）6—2，3，4，5（判断是否能被2,3,4,5整除）… 以下是js代码的实现：123456789101112for(let i=2;i&lt;=100;i++)&#123; let flag = true; for(let j=2;j&lt;i;j++)&#123; if(i%j==0)&#123; flag = false; break; &#125; &#125; if(flag)&#123; console.log(i) &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统分类]]></title>
    <url>%2F2018%2F02%2F27%2Flinux%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一般来说著名的linux系统基本上分两大类： RedHat系列：Redhat、Centos、Fedora等 Debian系列：Debian、Ubuntu等 RedHat系列常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数” 包管理工具 yum 123456789yum的配置文件：/etc/yum.conf yum install gcc [centos] 更新：yum update 安装：yum install xxx 移除：yum remove xxx 清除已经安装过的档案（/var/cache/yum/）：yum clean all 搜寻：yum search xxx 列出所有档案：yum list 查询档案讯息：yum info xxx 支持tar包 Debian系列常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数” 包管理工具 apt-get 1234更新软件包：apt-get update安装：apt-get install xxx移除：apt-get remove xxx更新安装过的包：apt-get upgrade xxx 支持tar包]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6基础]]></title>
    <url>%2F2018%2F02%2F26%2Fes6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[let命令let有块级作用域，let声明的变量只在它所在的代码块有效 var有变量提升现象，let没有变量提升 let暂时性死区123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错let不允许重复声明一道面试题：1234567var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i) &#125;)&#125;funcs.forEach(function(func) &#123; func()&#125;) 以上代码会输出10次数组10，如果想要输出0-9，两种解决方案：123456789101112131415// ES5告诉我们可以利用闭包解决这个问题var funcs = []for (var i = 0; i &lt; 10; i++) &#123; func.push((function(value) &#123; return function() &#123; console.log(value) &#125; &#125;(i)))&#125;// es6for (let i = 0; i &lt; 10; i++) &#123; func.push(function() &#123; console.log(i) &#125;)&#125; 模板字符串字符串拼接 123456//es5 var name = 'lux'console.log('hello' + name)//es6const name = 'lux'console.log(`hello $&#123;name&#125;`) //hello lux es6提供的常用的字符串方法 1234567// includes：判断是否包含然后直接返回布尔值let str = 'hahay'console.log(str.includes('y')) // true// repeat: 获取字符串重复n次let s = 'he'console.log(s.repeat(3)) // 'hehehe' 函数默认参数1234567891011121314//es5设置参数默认值//这种方式如果num=0就会出现num的值被默认200覆盖 function action(num) &#123; num = num || 200 //当传入num时，num为传入的值 //当没传入参数时，num即有了默认值200 return num &#125;//es6设置默认参数 function action(num = 200) &#123; console.log(num) &#125; action() //200 action(300) //300 箭头函数 三个特点: 不需要function关键字来创建函数 省略return关键字 继承当前上下文的 this 关键字 1234567//例如： [1,2,3].map( x =&gt; x + 1 ) //等同于： [1,2,3].map((function(x)&#123; return x + 1 &#125;).bind(this)) 拓展的对象功能对象初始化简写12345678let name = 'danw'let age = 27var d = &#123;name:name,age:age&#125;//以上代码es6可以简写为：let name = 'danw'let age = 27var d = &#123;name,age&#125; 对象初始化中方法赋值的简写12345678910111213const people = &#123; name: 'lux', getName: function() &#123; console.log(this.name) &#125;&#125;//以上代码简写如下：const people = &#123; name: 'lux', getName () &#123; console.log(this.name) &#125;&#125; Object.assign()实现对象浅复制12345var objA = &#123;a：1,b:2&#125;const obj = Object.assign(&#123;&#125;, objA)obj.c = 3console.log(obj) //&#123;a：1,b:2,c:3&#125;console.log(objA) //&#123;a：1,b:2&#125; objA的值不会被改变 更方便的数据访问–解构12345678910111213const people = &#123; name: 'lux', age: 20&#125;const name = people.nameconst age = people.ageconsole.log(name + ' --- ' + age)//对象解构取值const &#123;name,age&#125; = people//数组结构取值const color = ['red', 'blue']const [first, second] = color Spread Operator 展开运算符（…）123456789//数组const color = ['red', 'yellow']const colorful = [...color, 'green', 'pink']console.log(colorful) //[red, yellow, green, pink]//对象const alp = &#123; fist: 'a', second: 'b'&#125;const alphabets = &#123; ...alp, third: 'c' &#125;console.log(alphabets) //&#123; "fist": "a", "second": "b", "third": "c" import 和 export用法总结 当用export default people导出时，就用 import people 导入（不带大括号） 一个文件里，有且只能有一个export default。但可以有多个export。 当用export name 时，就用import { name }导入（记得带上大括号） 当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, { name, age } 当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example Promise思考题1234567891011121314setTimeout(function() &#123; console.log(1) &#125;, 0); new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3); &#125;).then(function() &#123; console.log(4); &#125;); console.log(5);//输出：2 3 5 4 1 类似面试题：https://zhuanlan.zhihu.com/p/25407758]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript的GC理解]]></title>
    <url>%2F2018%2F02%2F24%2Fjavascript%E7%9A%84GC%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[js会将我们使用不到的变量销毁，怎么判断哪些变量是不会再使用的 全局变量是不会被销毁的，因为我们随时都可能会用到这个变量，所以不能被销毁。 函数内部的变量再函数执行完之后就会被销毁，但是如果这个函数有被外部的变量引用就不会销毁12345678910function a()&#123; var b = 0; return function()&#123; b ++; console.log(b); &#125;&#125;var d = a();d();//1d();//2]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call()、apply()、bind()区别]]></title>
    <url>%2F2018%2F02%2F24%2Fcall()%E3%80%81apply()%E3%80%81bind()%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[执行的环境thisthis指向：this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的 apply(),call(),bind()都是改变函数执行的环境（this）的，apply(),call()改变函数的this之后会立即执行函数，而bind()返回的是被修改this之后的新函数，在需要调用的时候去调用这个新函数，并且可以在执行的执行的时候去传递参数。 12345678var a = &#123; user:"danw", fn:function ()&#123; console.log(this.user) &#125;&#125;var b = a.fnb() //undefined 上面的代码之所以返回undefined是因为b在调用的时候是window.b(),this指向的是window，如果直接执行a.fn就会返回a里面的user1234567var a = &#123; user:"danw", fn:function ()&#123; console.log(this.user) &#125;&#125;a.fn() //danw 虽然这种方式可以正确的返回，但是有时间我们不得不将对象赋值给另一个变量，这时候就需要使用以下三种方法来改变this指向： call()12345678var a = &#123; user:"danw", fn:function ()&#123; console.log(this.user) &#125;&#125;var b = a.fnb.call(a) //danw 通过call方法将b添加到a执行环境中去执行，所有this就会指向acall方法还可以传递多个参数12345678var a = &#123; user:"danw", fn:function (p1,p2)&#123; console.log(this.user) &#125;&#125;var b = a.fnb.call(a,1,2) //danw apply()apply和call方法的效果一样，唯一不同的是在传递参数的时候是按照数组传递的。12345678var a = &#123; user:"danw", fn:function (p1,p2)&#123; console.log(this.user) &#125;&#125;var b = a.fnb.apply(a,[1,2]) //danw bind()bind()方法和apply(),call()方法一样会改变this指向，但是bind()方法不会立即去执行函数12345678var a = &#123; user:"danw", fn:function ()&#123; console.log(this.user) &#125;&#125;var b = a.fnb.bind(a) 执行上面代码发现并没有打印出结果，是因为b.bind(a)会返回一个新的函数123456789var a = &#123; user:"danw", fn:function ()&#123; console.log(this.user) &#125;&#125;var b = a.fnvar c = b.bind(a) //返回新的函数cc() //danw 执行函数c,会返回danw 所以谁bind()可以让对应的函数想什么时候执行就什么时候执行bind()也可以传递参数,并且可以在执行的时候再次追加参数12345678910var a = &#123; user:"danw", fn:function (p1,p2,p3)&#123; console.log(p1,p2,p3) //1,2,3 console.log(this.user) &#125;&#125;var b = a.fnvar c = b.bind(a,1) //返回新的函数cc(2,3) //danw 执行函数c,会返回danw]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>call()</tag>
        <tag>apply()</tag>
        <tag>bind()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise深入理解]]></title>
    <url>%2F2018%2F02%2F12%2Fpromise%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[promise是什么promise 是一个构造函数，自己身上有all、reject、resolve这些方法，原型上有then、catch这些方法，用Promise new出来的对象肯定就有then、catch方法。1234567var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('执行完成'); resolve('随便什么数据'); &#125;, 2000);&#125;); *注意，这里知识new了一个Promise对象，并没有去调用它，但是传进去的函数已经之行了，所以在使用Promise的时候一般是包在一个函数中，使用的时候再去调用函数。 promise链式操作调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function runAsync1()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('runAsync1执行完成'); resolve('runAsync1随便什么数据'); &#125;, 2000); &#125;);&#125;function runAsync2()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('runAsync2执行完成'); resolve('runAsync2随便什么数据'); &#125;, 2000); &#125;);&#125;function runAsync3()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('runAsync3执行完成'); resolve('runAsync3随便什么数据'); &#125;, 2000); &#125;);&#125;runAsync1().then(data =&gt; &#123; console.log(data)//runAsync1函数的resolve结果 return runAsync2()&#125;).then(data =&gt; &#123; console.log(data)//runAsync2函数的resolve结果 return runAsync3()&#125;).then(data =&gt; &#123; console.log(data) //runAsync3函数的resolve结果 &#125;)//如果当前函数执行不依赖于上一个函数的返回值，也可以这样写:runAsync1().then(runAsync2).then(runAsync3).then(data =&gt; &#123; console.log(data) //这里只能拿到runAsync3函数的resolve结果 &#125;)//当然这种方式也可以手动在每一个函数内部获取上一个函数的返回值，例如runAsync2想要使用runAsync1的返回值，runAsync2就得这样写：function runAsync2(data)&#123; console.log(data)//data为runAsync1函数的resolve结果 return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('runAsync2执行完成'); resolve('runAsync2随便什么数据'); &#125;, 2000); &#125;);&#125; 异常处理使用catch处理异常then方法有两个参数，第一个是处理resolve的回调，第二个是处理reject的回调，catch和then的第二个参数一样也是指定reject回调的。以上面的列子说明： 可以在then的第二个参数里面处理error 1234567891011runAsync1().then(data =&gt; &#123; console.log(data)//runAsync1函数的resolve结果 return runAsync2()&#125;).then(data =&gt; &#123; console.log(data)//runAsync2函数的resolve结果 return runAsync3()&#125;).then(data =&gt; &#123; console.log(data) //runAsync3函数的resolve结果 &#125;,err=&gt;&#123; console.log(err)&#125;) 也可以放在then方法的外面使用catch处理，效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中 1234567891011runAsync1().then(data =&gt; &#123; console.log(data) return runAsync2()&#125;).then(data =&gt; &#123; console.log(data) return runAsync3()&#125;).then(data =&gt; &#123; console.log(data) &#125;).catch(err =&gt; &#123; console.log(err)&#125;) *注意，不管runAsync1、runAsync2、runAsync3出现异常，都会走到catch中，如果runAsync1出现异常，runAsync2、runAsync3都不会执行。 Promise.all使用（谁执行的慢以谁为准执行回调，但是返回值是所有的返回值集合）并行执行一组异步操作，并且返回值是所有异步操作返回值的数组12345Promise .all([runAsync1(), runAsync2(), runAsync3()]) .then(function(results)&#123; console.log(results);&#125;); Promise.race（谁执行的快以谁为准执行回调）使用场景：可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作12345Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 示例代码：12345678910111213141516171819202122232425262728//10秒之后执行function timeout10()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; resolve('success'); &#125;, 4000); &#125;); return p;&#125;//延时函数，用于给请求计时function timeout5()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; reject('请求超时'); &#125;, 5000); &#125;); return p;&#125;Promise.race([timeout10(), timeout5()]).then(function(results)&#123; console.log(results);&#125;).catch(function(reason)&#123; console.log(reason);&#125;); 参考帖子：http://www.cnblogs.com/lvdabao/p/es6-promise-1.html]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下使用tree命令]]></title>
    <url>%2F2018%2F02%2F10%2Fmac%E4%B8%8B%E4%BD%BF%E7%94%A8tree%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[mac下默认是没有 tree命令的，不过我们可以使用find命令模拟出tree命令的效果 如显示当前目录的 tree 的命令1find . -print | sed -e &apos;s;[^/]*/;|____;g;s;____|; |;g&apos; 使用alias 指定别名，将它变成一个命令 .bash_profile文件增加以下代码： 1alias tree=&quot;find . -print | sed -e &apos;s;[^/]*/;|____;g;s;____|; |;g&apos;&quot;]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node四个定时器]]></title>
    <url>%2F2018%2F02%2F09%2FNode%E5%9B%9B%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[为了协调异步任务，Node 提供了四个定时器，让任务可以在指定的时间运行。 setTimeout() setInterval() setImmediate() process.nextTick() 猜测一下以下代码的运行结果12345setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));(() =&gt; console.log(5))(); 运行结果如下。1234553412 同步代码先于异步代码执行 异步任务分为： 追加在本轮循环的异步代码 追加在次轮循环的异步代码 1234567// 下面两行，次轮循环执行 等待时间相同的情况下setTimeout先于setInterval执行setTimeout(() =&gt; console.log(1));setInterval(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));// 下面两行，本轮循环执行process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4)); setTimeout次轮循环中执行 setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。 setImmediate次轮循环中执行 setImmediate()是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行setImmediate指定的回调函数，和setTimeout(fn,0)的效果差不多，但是当他们同时在同一个事件循环中时，执行顺序是不定的。 process.nextTick本轮循环中执行 同步代码执行完之后立即执行，所有异步里面最快的 process.nextTick()方法可以在当前”执行栈”的尾部–&gt;下一次Event Loop（主线程读取”任务队列”）之前–&gt;触发process指定的回调函数。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。（nextTick虽然也会异步执行，但是不会给其他io事件执行的任何机会） 最后process.maxTickDepth()的缺省值是1000，如果超过会报exceed callback stack。官方认为在递归中用process.nextTick会造成饥饿event loop，因为nextTick没有给其他异步事件执行的机会，递归中推荐用setImmediate]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>setTimeout</tag>
      </tags>
  </entry>
</search>
