<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常见算法总结]]></title>
    <url>%2F2018%2F09%2F12%2Farithmetic%2F</url>
    <content type="text"><![CDATA[自定义实现一个 js 数组的 map 函数 123456789101112function map(arr, fn) &#123; let newlist = []; for (let i = 0; i &lt; arr.length; i++) &#123; newlist[i] = fn(arr[i], i, arr); &#125; return newlist;&#125;console.log( map(list, item =&gt; &#123; return item + 1; &#125;)); 自定义实现一个 js 数组的 filter 函数 123456789101112131415let list = [1, 2, 3, 4, 5, 6];function filter(arr, fn) &#123; let newlist = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (fn(arr[i], i, arr)) &#123; newlist.push(arr[i]); &#125; &#125; return newlist;&#125;console.log( filter(list, item =&gt; &#123; return item &gt; 2; &#125;)); 输出 1-100 之间的素数 素数：除了 1 和它本身外没有其他因数，即，除了 1 和它本身外不能被其他数整除1—不是素数2—最小的素数3—2（判断是否能被 2 整除）4—2，3（判断是否能被 2,3 整除）5—2，3，4（判断是否能被 2,3,4 整除）6—2，3，4，5（判断是否能被 2,3,4,5 整除） 123456789101112for (let i = 2; i &lt;= 100; i++) &#123; let flag = true; for (let j = 2; j &lt; i; j++) &#123; if (i % j == 0) &#123; flag = false; break; &#125; &#125; if (flag) &#123; console.log(i); &#125;&#125; js 实现冒泡排序算法 原理：将前后两个数进行比较，较大或者较小的往后放例如：let numbers={ 1,5,3,6,4,9,8,0,7,2}第一轮比较：第一次比较：1，5，3，6，4，9，8，0，7，2 第一个数不大于第二个数，不调换位置 第二次比较：1，3，5，6，4，9，8，0，7，2 第二个数大于第三个数，调换位置 第三次比较：1，3，5，6，4，9，8，0，7，2 第三个数不大于第四个数，不调换位置 第四次比较：1，3，5，4，6，9，8，0，7，2 第四个数大于第五个数，调换位置...以此类推 第九次比较：1，3，5，4，6，8，0，7，2，9 第九个数大于第十个数，调换位置 第二轮比较：比较次数 8 次 第三轮比较：比较次数 7 次...以此类推 第九轮比较 1 次从上面的分析我们可以看出我们排 10 个数需要比较九轮，每一轮比较由 9 次递减到 1 次 以下是 js 代码的实现： 1234567891011121314var arr = [2, 10, 3, 4, 1, 7, 5, 6, 9, 8];function sort(arr) &#123; for (let i = 0; i &lt; arr.length - 1; i++) &#123; for (let j = 0; j &lt; arr.length - 1 - i; j++) &#123; let temp = arr[j]; if (arr[j] &gt; arr[j + 1]) &#123; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;sort(arr);console.log(arr); js 实现插入排序算法 原理：从下标 1 开始，current=array[i],对数组的前 i-1 项进行检查，如果存在大于 current 值，将此值往后移，赋值给下一项 12345678910111213141516function sort(arr) &#123; for (let i = 1; i &lt; arr.length; i++) &#123; let current = arr[i]; var index = i; //记录要被插入的下标 for (let j = i - 1; j &gt;= 0; j--) &#123; if (current &lt; arr[j]) &#123; arr[j + 1] = arr[j]; index = j; &#125; &#125; arr[index] = current; &#125; return arr;&#125;let arr = [34, 8, 64, 51, 32, 21];console.log(sort(arr)); 爬楼梯问题（斐波拉契数列） 问题：楼梯总共有 N 级，若每次只能跨上一级或二级或者三级，要走上第 N 级，共有多少种走法？思路：N = 1 的时候只有 1 种方法。N = 2 的时候有 2 方法。N = 3 的时候有 4 方法。N = K 的时候，可以先走到 k-1 那里，然后向前走一阶，或者先走到 k-2 那里然后前走两阶所以后一个答案是前两个的答案之和。 1234567function f(n) &#123; if (n &lt; 3) return n; if (n == 3) &#123; return 4; &#125; return f(n - 1) + f(n - 2) + f(n - 3);&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker部署easy-mock]]></title>
    <url>%2F2018%2F09%2F04%2Feasy-mock-deploy%2F</url>
    <content type="text"><![CDATA[easy-mock 是一个开源的持久的服务，可以快速生成模拟数据并提供可视化视图，使用 easy-mock 在实际开发中可以更好的将前后端开发分离并行开发，避免前端一直等待后台接口的尴尬局面，接下来演示一下如何使用 docker 部署一个 easy-mock 克隆 easy-mock 源码到本地1git clone https://github.com/easy-mock/easy-mock.git build 镜像进入项目目录，在根路径下创建 Dockerfile 文件,文件内容如下 1234567891011121314151617FROM keymetrics/pm2:latest-alpine# Bundle APP filesCOPY . ./app# Install app dependenciesENV NPM_CONFIG_LOGLEVEL warnENV PORT 7300ENV NODE_ENV production# Show current folder structure in logsRUN ls -alWORKDIR ./appEXPOSE 7300CMD [ &quot;pm2-runtime&quot;, &quot;start&quot;, &quot;pm2.json&quot; ] 项目使用 pm2 启动，因此在根路径下创建一个 pm2 的配置文件 pm2.json,内容如下,具体每个配置的意义可以查阅 pm2 文档 12345678910111213141516&#123; &quot;apps&quot;: [ &#123; &quot;script&quot;: &quot;./app.js&quot;, &quot;name&quot;: &quot;easy-mock&quot;, &quot;interpreter&quot;: &quot;node&quot;, &quot;env&quot;: &#123; &quot;NODE_ENV&quot;: &quot;production&quot; &#125;, &quot;out_file&quot;: &quot;easy-mock.log&quot;, &quot;error_file&quot;: &quot;easy-mock-err.log&quot;, &quot;watch&quot;: &quot;./config/&quot;, &quot;restart_delay&quot;: 2000 &#125; ]&#125; 准备好以上两个文件后开始使用 docker 命令 Build 镜像 1docker build -t hub.c.163.com/dandanwu/easy-mock . build 成功之后使用 docker images 可以看到 build 出来的脚本 运行easy-mock 的运行依赖于 mongodb 以及 redis，因此需要启动 mongo、redis,都是用 docker 启动 12345redisdocker run --name redis --restart always -p 6379:6379 -v /root/docker-data/redis/data:/data -d redis redis-server --appendonly yesmongodocker run --name mongo --restart always -v /root/docker-data/mongo/data:/data/db -d -p 27017:27017 mongo 由于 mongo 和 redis 我们使用了 docker 启动，因此需要修改 easy-mock 的源码中的配置文件 config/default.json 12345678&quot;db&quot;: &quot;mongodb://mongo/easy-mock&quot;, &quot;redis&quot;: &#123; &quot;keyPrefix&quot;: &quot;[Easy Mock]&quot;, &quot;port&quot;: 6379, &quot;host&quot;: &quot;redis&quot;, &quot;password&quot;: &quot;&quot;, &quot;db&quot;: 0 &#125;, 最后运行 easy-mock 镜像，link 到 mongo 以及 redis 1docker run -d -p 7300:7300 --restart always --link=mongo:mongo --link=redis:redis hub.c.163.com/dandanwu/easy-mock 成功后访问 http://localhost:7300 可以看到以下界面，表明部署成功！部署成功后默认会有一个演示的项目]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker easy-mock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解VirtualDOM]]></title>
    <url>%2F2018%2F09%2F01%2FVirtualDOM%2F</url>
    <content type="text"><![CDATA[数据变更与 UI 同步发展历史 早期，页面是静态的，数据发生变化就需要刷新页面来更新页面 刷新页面性能受到影响，并且用户体验不好，因此出现只更新变化数据对应的页面，使用 js 操作 dom 来实现 开发通过操作 dom 实现部分页面更新很麻烦，因此一些框架诞生，借助框架，监听数据变更，变更后更新对应的 dom 节点，开发者编码减少 MVVM 框架出现了，以 AngularJS 为代表 React 出现，他不是 MVVM 框架，它的实现思路：回到最初的方案，如果数据变化就重新执行一次整体的渲染，不用去管数据的那部分发生了变化，但是这样体验太差，因此 react 引入了 Virtual DOM 实现了性能上的优化 Virtual DOM在数据与真实的 dom 之前建立一层缓冲，数据变化了就调用 react 的渲染方法，react 并不是直接得到新的 dom 然后替换，而是先生成 Virtual DOM 然后在与上一次渲染得到的 Virtual DOM 进行对比，得到差异的地方，再把差异的地方更新到真实的 dom Virtual Dom 算法的实现 通过 JS 来模拟创建 DOM 对象 判断两个对象的差异(diff) 渲染差异(patch) diff 算法从左到右从上到下遍历 dom 树，每个节点都有一个唯一的 key两个节点对比： 新的节点的 tagname 或者 key 和旧的不同，则直接替换节点，不需要遍历旧节点的子元素 新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树 没有新的节点，那么什么都不用做]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Virtual DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs模块机制理解]]></title>
    <url>%2F2018%2F07%2F29%2Fnodejs-module-mechanism%2F</url>
    <content type="text"><![CDATA[CommonJS规范CommonJS出发点: js没有模块系统、缺乏包管理系统、标准库较少 CommonJS规范涵盖了模块，二进制 ,Buffer,字符集编码,I/O流, 进程环境,文件系统,接】套接字,单元测试,web服务器网关接口, 包管理等。 CommonJS对模块的定义包含：模块引用:（var math = require(‘math’)）模块定义:一个文件就是一个模块,将方法挂在到exports对象上做法属性定义导出module对象代表模块本身，exports是module的属性模块标志:require(‘math’)方法的参数，可以是字符串，相对路径，绝对路径 Node中模块分类: node提供的模块（核心模块）、用户编写的模块（文件模块） 模块引入的步骤： 路径分析 文件定位 编译执行 优先从缓存加载 核心模块部分在node源代码编译时候已被编译进了二进制执行文件，Node启动时候被加载进内存，引入时候无需文件定位，编译执行，速度最快，仅次于缓存加载 路径分析根据模块标识符分析，不同标识符分析方式不同 标识符分类： 核心模块（http,fs，path）已被编译为二进制代码，加载速度最快 以.或者../开头的相对路径将路径转换为真实路径，以路径为索引加载，将编译执行后的结果放入缓存中，加载速度仅次于核心模块 非路径形式的文件模块（express）使用模块路径查找策略，会生成一个数组，生成规则是当前路径的node_modules、父目录下的node_modules、父目录的父目录的node_modules，依次往上查找，当前文件路径越深，查找越费时，这种文件模块的查找最慢 文件定位扩展名分析顺序：.js、.json、.node(C/C++编写的模块) 分析查找标识符过程中如果没有得到一个文件却得到了一个目录，此时查找顺序是：1、找到package.json2、通过JSON.parse()解析出包描述对象，找到main属性指定的文件名进行定位3、若第二步的文件名没有扩展，则进行扩展名分析4、如查找main指定的文件错误，或没有package.json则，默认查找index文件，依次查找index.js,index.josn,index.node5、若以上四步定位失败，则进入下一个模块路径查找 编译 .js文件 （fs模块读取编译执行） 编译的时候对js代码进行头尾包装，以实现作用域隔离 (function(exports,require,module,_filename,_dirname){ var math = require('math') exports.area = function (radius){ retutn Math.PI * radius * radius } }) .json（fs读取后，通过JSON.parse()解析返回结果） .node(c/c++编写的扩展模块，通过dlopen()加载最后编译)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>commonjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的模块规范]]></title>
    <url>%2F2018%2F07%2F18%2Fjs-module-specification%2F</url>
    <content type="text"><![CDATA[js 中的模块规范CommonJS主要应用于服务器，实现同步加载 模块输出方式：exports 和 module.exports 模块输入方式：require 123var math = require("math");math.add(2, 3); 前者支持动态导入，也就是 require(${path}/xx.js) node.js 的模块系统，就是参照 CommonJS 规范实现的 AMDAMD 规范应用于浏览器，如 requirejs，为异步加载 模块输出方式：define([‘dependency’], callback); 模块输入方式：require([module], callback); 第一个参数为需要加载的模块名称，第二个参数为加载完模块之后需要执行的回调函数 123require(["math"], function(math) &#123; math.add(2, 3);&#125;); 主要有两个 Javascript 库实现了 AMD 规范：require.js 和 curl.js CMD同步加载方案 CMD 有个浏览器的实现 SeaJS 12345678// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require("jquery.js"); $("div").addClass("active");&#125;);// 加载模块seajs.use(["myModule.js"], function(my) &#123;&#125;); ES6 模块规范浏览器和服务器通用的模块解决方案。 不支持动态导入，但是已有提案 模块输出方式：export 和 export default 模块输入方式：import … from …]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>模块规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装配置使用Postgresql]]></title>
    <url>%2F2018%2F06%2F20%2F1529497233114%2F</url>
    <content type="text"><![CDATA[安装配置执行安装命令 123# yum install postgresql-server# yum install postgresql-contrib 启动postgresql服务初次启动会报错，是因为没有初始化数据库 12# systemctl start postgresqlJob for postgresql.service failed because the control process exited with error code. See &quot;systemctl status postgresql.service&quot; and &quot;journalctl -xe&quot; for details. 初始化数据库 1# postgresql-setup initdb 再次启动postgresql服务 1# systemctl start postgresql 查看postgresql状态 12345678910111213141516171819# systemctl status postgresql● postgresql.service - PostgreSQL database server Loaded: loaded (/usr/lib/systemd/system/postgresql.service; disabled; vendor preset: disabled) Active: active (running) since Wed 2018-06-20 16:38:12 CST; 3h 57min ago Process: 15941 ExecStop=/usr/bin/pg_ctl stop -D $&#123;PGDATA&#125; -s -m fast (code=exited, status=0/SUCCESS) Process: 15948 ExecStart=/usr/bin/pg_ctl start -D $&#123;PGDATA&#125; -s -o -p $&#123;PGPORT&#125; -w -t 300 (code=exited, status=0/SUCCESS) Process: 15942 ExecStartPre=/usr/bin/postgresql-check-db-dir $&#123;PGDATA&#125; (code=exited, status=0/SUCCESS) Main PID: 15952 (postgres) CGroup: /system.slice/postgresql.service ├─15952 /usr/bin/postgres -D /var/lib/pgsql/data -p 5432 ├─15953 postgres: logger process ├─15955 postgres: checkpointer process ├─15956 postgres: writer process ├─15957 postgres: wal writer process ├─15958 postgres: autovacuum launcher process └─15959 postgres: stats collector processJun 20 16:38:11 JD systemd[1]: Starting PostgreSQL database server...Jun 20 16:38:12 JD systemd[1]: Started PostgreSQL database server. 设置开机自启动 1# systemctl enable postgresql su – postgres切换到postgresql用户执行psql的操作 123456789# su - postgresLast login: Wed Jun 20 16:36:25 CST 2018 on pts/0Last failed login: Wed Jun 20 20:39:12 CST 2018 from server2.4puntozero.it on ssh:nottyThere were 4 failed login attempts since the last successful login.-bash-4.2$ psqlpsql (9.2.23)Type &quot;help&quot; for help.postgres=# 查看所有数据库 12345678910postgres=# \l List of databases Name | Owner | Encoding | Collate | Ctype | Access privileges-----------+-----------+-----------+-------------+-------+------------------------- postgres | postgres | SQL_ASCII | en_US.UTF-8 | C | template0 | postgres | SQL_ASCII | en_US.UTF-8 | C | =c/postgres + | | | | | postgres=CTc/postgres template1 | postgres | SQL_ASCII | en_US.UTF-8 | C | =c/postgres + | | | | | postgres=CTc/postgres(4 rows) 创建用户 12postgres=# CREATE USER username WITH PASSWORD &apos;password&apos;;CREATE ROLE 为用户创建数据库 12postgres=# CREATE DATABASE dbname OWNER username;CREATE DATABASE 给用户所有操作创建的数据库的权限 12postgres=# GRANT ALL PRIVILEGES ON DATABASE dbname to username;GRANT 到此postgresql安装成功！ 配置远程连接如果想要在客户端工具（像pgAdmin）中连接postgres，需要设置postgres远程连接修改data目录下的pg_hba.conf和postgresql.conf 12345# vi postgresql.conf修改 listen_addresses=&apos;localhost&apos;为listen_addresses=&apos;*&apos; 1234# vi pg_hba.conf在底部增加以下配置host all all 0.0.0.0/0 md5 如果不希望允许所有IP远程访问，则可以将上述配置项中的0.0.0.0设定为特定的IP值。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[consul入门]]></title>
    <url>%2F2018%2F06%2F19%2F1529389603595%2F</url>
    <content type="text"><![CDATA[概述consul 是一个服务发现、服务配置的工具，具有以下特征： 服务发现 健康检查 key/value 存储 多数据中心 consul 每个节点都需要运行 agent，他有两种运行模式 server 和 client。每个数据中心官方建议需要 3 或 5 个 server 节点 server 模式服务端模式下，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的 client 模式客户端是一个非常轻量级的进程，它注册服务，运行健康检查，以及转发查询到服务器，不会持久化信息 安装在 consul 官网下载页面找到和系统匹配的安装包，这里以 linux 为列首先下载二进制包并解压 12# wget https://releases.hashicorp.com/consul/1.1.0/consul_1.1.0_linux_amd64.zipunzip consul_1.1.0_linux_amd64.zip 配置环境变量，使其全局生效,编辑系统变量文件 /etc/profile 在末尾增加如下配置： 1# export PATH=$PATH:/consul_path/ （此处填写解压后的consul文件地址） 使环境变量立即生效 1# source /etc/profile 执行 consul 命令，看到 consul 提示，说明 consul 安装成功 1234567891011121314151617181920212223242526# consulUsage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]Available commands are: agent Runs a Consul agent catalog Interact with the catalog event Fire a new event exec Executes a command on Consul nodes force-leave Forces a member of the cluster to enter the &quot;left&quot; state info Provides debugging information for operators. join Tell Consul agent to join cluster keygen Generates a new encryption key keyring Manages gossip layer encryption keys kv Interact with the key-value store leave Gracefully leaves the Consul cluster and shuts down lock Execute a command holding a lock maint Controls node or service maintenance mode members Lists the members of a Consul cluster monitor Stream logs from a Consul agent operator Provides cluster-level tools for Consul operators reload Triggers the agent to reload configuration files rtt Estimates network round trip time between nodes snapshot Saves, restores and inspects snapshots of Consul server state validate Validate config files/directories version Prints the Consul version watch Watch for changes in Consul 运行 Agent使用 dev 模式可以简单地启动一个单节点 consul 服务 123456789101112131415161718192021222324252627282930313233343536373839# consul agent -dev==&gt; Starting Consul agent...==&gt; Consul agent running! Version: &apos;v1.1.0&apos; Node ID: &apos;49afc899-5629-adaf-b008-3dd6ca5da620&apos; Node name: &apos;danw-MacBook-Pro&apos; Datacenter: &apos;dc1&apos; (Segment: &apos;&lt;all&gt;&apos;) Server: true (Bootstrap: false) Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, DNS: 8600) Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302) Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false==&gt; Log data will now stream in as it occurs: 2018/06/19 15:11:38 [DEBUG] agent: Using random ID &quot;49afc899-5629-adaf-b008-3dd6ca5da620&quot; as node ID 2018/06/19 15:11:38 [INFO] raft: Initial configuration (index=1): [&#123;Suffrage:Voter ID:49afc899-5629-adaf-b008-3dd6ca5da620 Address:127.0.0.1:8300&#125;] 2018/06/19 15:11:38 [INFO] raft: Node at 127.0.0.1:8300 [Follower] entering Follower state (Leader: &quot;&quot;) 2018/06/19 15:11:38 [INFO] serf: EventMemberJoin: danw-MacBook-Pro.dc1 127.0.0.1 2018/06/19 15:11:38 [INFO] serf: EventMemberJoin: danw-MacBook-Pro 127.0.0.1 2018/06/19 15:11:38 [INFO] consul: Adding LAN server danw-MacBook-Pro (Addr: tcp/127.0.0.1:8300) (DC: dc1) 2018/06/19 15:11:38 [INFO] consul: Handled member-join event for server &quot;danw-MacBook-Pro.dc1&quot; in area &quot;wan&quot; 2018/06/19 15:11:38 [INFO] agent: Started DNS server 127.0.0.1:8600 (tcp) 2018/06/19 15:11:38 [INFO] agent: Started DNS server 127.0.0.1:8600 (udp) 2018/06/19 15:11:38 [INFO] agent: Started HTTP server on 127.0.0.1:8500 (tcp) 2018/06/19 15:11:38 [INFO] agent: started state syncer 2018/06/19 15:11:38 [WARN] raft: Heartbeat timeout from &quot;&quot; reached, starting election 2018/06/19 15:11:38 [INFO] raft: Node at 127.0.0.1:8300 [Candidate] entering Candidate state in term 2 2018/06/19 15:11:38 [DEBUG] raft: Votes needed: 1 2018/06/19 15:11:38 [DEBUG] raft: Vote granted from 49afc899-5629-adaf-b008-3dd6ca5da620 in term 2. Tally: 1 2018/06/19 15:11:38 [INFO] raft: Election won. Tally: 1 2018/06/19 15:11:38 [INFO] raft: Node at 127.0.0.1:8300 [Leader] entering Leader state 2018/06/19 15:11:38 [INFO] consul: cluster leadership acquired 2018/06/19 15:11:38 [INFO] consul: New leader elected: danw-MacBook-Pro 2018/06/19 15:11:38 [DEBUG] consul: Skipping self join check for &quot;danw-MacBook-Pro&quot; since the cluster is too small 2018/06/19 15:11:38 [INFO] consul: member &apos;danw-MacBook-Pro&apos; joined, marking health alive 2018/06/19 15:11:38 [DEBUG] agent: Skipping remote check &quot;serfHealth&quot; since it is managed automatically 2018/06/19 15:11:38 [INFO] agent: Synced node info 2018/06/19 15:11:40 [DEBUG] agent: Skipping remote check &quot;serfHealth&quot; since it is managed automatically 2018/06/19 15:11:40 [DEBUG] agent: Node info in sync 查看集群成员 123# consul membersNode Address Status Type Build Protocol DC Segmentdanw-MacBook-Pro 127.0.0.1:8301 alive server 1.1.0 2 dc1 &lt;all&gt; 停止 Agent可以使用 ctrl+c 直接停止 agent 服务 搭建 consul 集群前面只是运行了一个 dev 模式的 consul 环境，并不能用于生产环境，也不会持久化任何信息，接下来我们搭建 3 个节点的 consul 服务 准备三台虚拟机 ip 虚拟名 10.211.55.4 s1 10.211.55.5 s2 10.211.55.6 s3 以下简称 s1,s2,s3 在每台虚机上执行对应的命令 s1: 1# consul agent -server -bootstrap-expect 3 -data-dir /tmp/consul_server -node consul-one -bind 10.211.55.4 -client 0.0.0.0 -ui s2: 1# consul agent -server -bootstrap-expect 3 -data-dir /tmp/consul_server -node consul-two -bind 10.211.55.5 -client 0.0.0.0 -ui -join 10.211.55.4 s3: 1# consul agent -server -bootstrap-expect 3 -data-dir /tmp/consul_server -node consul-three -bind 10.211.55.6 -client 0.0.0.0 -ui -join 10.211.55.5 参数说明： -server: 指定 agent 以 server 模式运行 -bootstrap-expect: 期望的节点数，只有集群数量达到设置值，集群才会选举 leader -data-dir: 数据目录 -node: 指定节点名称 -bind: 为节点绑定地址 -client: 指定 web ui、的监听地址，默认 127.0.0.1 只能本机访问 -ui: 启用内置的静态 web UI 服务器(8500 端口) -join: 加入集群 三台虚机上的 consul 全部启动之后，查看集群节点 12345[root@centos-linux ~]# consul membersNode Address Status Type Build Protocol DC Segmentconsul-one 10.211.55.4:8301 alive server 1.1.0 2 dc1 &lt;all&gt;consul-three 10.211.55.6:8301 alive server 1.1.0 2 dc1 &lt;all&gt;consul-two 10.211.55.5:8301 alive server 1.1.0 2 dc1 &lt;all&gt; 可以看到集群中已经有三个 alive 状态的节点打开浏览器访问http://10.211.55.4:8500可以看到集群信息]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>分布式，微服务</tag>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nomad初体验]]></title>
    <url>%2F2018%2F06%2F13%2F1529235554495%2F</url>
    <content type="text"><![CDATA[Nomad 是一个管理机器集群并在集群上运行应用程序的工具。支持多种驱动程序（Docker、VMS、Java）运行 job,操作简单，多数据中心，可以跨数据中心调度。 安装在 nomad 官网找到适合自己系统的安装包，这里以 linux 为列首先下载二进制包并解压 12# wget https://releases.hashicorp.com/nomad/0.8.4/nomad_0.8.4_linux_amd64.zipunzip nomad_0.8.4_linux_amd64.zip 配置环境变量，使其全局生效,编辑系统变量文件 /etc/profile 在末尾增加如下配置： 1# export PATH=$PATH:/nomad_path/ （此处填写解压后的nomad文件地址） 使环境变量立即生效 1# source /etc/profile 执行 nomad 命令，看到 nomad 提示，说明 nomad 安装成功 1234567891011121314151617181920212223Usage: nomad [-version] [-help] [-autocomplete-(un)install] &lt;command&gt; [args]Common commands: run Run a new job or update an existing job stop Stop a running job status Display the status output for a resource alloc Interact with allocations job Interact with jobs node Interact with nodes agent Runs a Nomad agentOther commands: acl Interact with ACL policies and tokens agent-info Display status information about the local agent deployment Interact with deployments eval Interact with evaluations namespace Interact with namespaces operator Provides cluster-level tools for Nomad operators quota Interact with quotas sentinel Interact with Sentinel policies server Interact with servers ui Open the Nomad Web UI version Prints the Nomad version 启动 Agent为了简单，我们启动一个开发模式的 agent，开发模式可以快速启动 server 端和 client 端 123456789101112131415161718192021222324252627282930313233# nomad agent -dev==&gt; Starting Nomad agent...==&gt; Nomad agent configuration: Client: true Log Level: DEBUG Region: global (DC: dc1) Server: true==&gt; Nomad agent started! Log data will stream in below: [INFO] serf: EventMemberJoin: nomad.global 127.0.0.1 [INFO] nomad: starting 4 scheduling worker(s) for [service batch _core] [INFO] client: using alloc directory /tmp/NomadClient599911093 [INFO] raft: Node at 127.0.0.1:4647 [Follower] entering Follower state [INFO] nomad: adding server nomad.global (Addr: 127.0.0.1:4647) (DC: dc1) [WARN] fingerprint.network: Ethtool not found, checking /sys/net speed file [WARN] raft: Heartbeat timeout reached, starting election [INFO] raft: Node at 127.0.0.1:4647 [Candidate] entering Candidate state [DEBUG] raft: Votes needed: 1 [DEBUG] raft: Vote granted. Tally: 1 [INFO] raft: Election won. Tally: 1 [INFO] raft: Node at 127.0.0.1:4647 [Leader] entering Leader state [INFO] raft: Disabling EnableSingleNode (bootstrap) [DEBUG] raft: Node 127.0.0.1:4647 updated peer set (2): [127.0.0.1:4647] [INFO] nomad: cluster leadership acquired [DEBUG] client: applied fingerprints [arch cpu host memory storage network] [DEBUG] client: available drivers [docker exec java] [DEBUG] client: node registration complete [DEBUG] client: updated allocations at index 1 (0 allocs) [DEBUG] client: allocs: (added 0) (removed 0) (updated 0) (ignore 0) [DEBUG] client: state updated to ready 从输出可以看到我们已经成功启动了 nomad server 端和 client 端访问本地 http://localhost:4646/ 可以看到 Nomad 自带的 ui 界面 集群节点打开另一个终端，运行一下命令可以看到 nomad 集群上已经注册的节点 123# nomad node statusID DC Name Class Drain Eligibility Status53f694be dc1 localhost.localdomain &lt;none&gt; false eligible ready 开发模式也启动了一个 server 端，所有运行下面的命令可以查看到 server 成员 123# nomad server membersName Address Port Status Leader Protocol Build Datacenter Regionlocalhost.localdomain.global 127.0.0.1 4648 alive true 2 0.8.1 dc1 global 如果需要停止 agent 只需要 Ctrl+C，就可以停止一个 agent Nomad Jobjob 是用户在使用 Nomad 时与之交互的主要配置，是 Nomad 应该运行的任务的声明性规范，Job 有一个全局唯一的名称，有一个或者多个任务组。 运行一个 Job进入到你的工作目录，使用 nomad inti 命令生成一个实例 job 配置文件:example.nomad 123# cd /root/nomad/# nomad initExample job file written to example.nomad 运行 job,可以看到 job 被分配到节点上运行 1234567# nomad job run example.nomad==&gt; Monitoring evaluation &quot;301af722&quot; Evaluation triggered by job &quot;example&quot; Evaluation within deployment: &quot;56ea1af8&quot; Allocation &quot;05e3f77a&quot; created: node &quot;53f694be&quot;, group &quot;cache&quot; Evaluation status changed: &quot;pending&quot; -&gt; &quot;complete&quot;==&gt; Evaluation &quot;301af722&quot; finished with status &quot;complete&quot; 查看 Job 状态 123# nomad job statusID Type Priority Status Submit Dateexample service 50 running 2018-06-13T19:28:21+08:00 如果想查看一个 Job 的详细信息 123456789101112131415161718192021222324252627282930# nomad server membersName Address Port Status Leader Protocol Build Datacenter Regionlocalhost.localdomain.global 127.0.0.1 4648 alive true 2 0.8.1 dc1 global[root@localhost nomad_cluster]# nomad job status exampleID = exampleName = exampleSubmit Date = 2018-06-13T19:28:21+08:00Type = servicePriority = 50Datacenters = dc1Status = runningPeriodic = falseParameterized = falseSummaryTask Group Queued Starting Running Failed Complete Lostcache 0 0 1 0 0 0Latest DeploymentID = 56ea1af8Status = failedDescription = Failed due to unhealthy allocationsDeployedTask Group Desired Placed Healthy Unhealthycache 1 1 0 1AllocationsID Node ID Task Group Version Desired Status Created Modified05e3f77a 53f694be cache 0 run running 3m51s ago 51s ago 修改一个 Job现在我们编辑 example.nomad 文件中 count 的，设置为 3,这个参数的作用是指定要运行的任务组数 1234# The &quot;count&quot; parameter specifies the number of the task groups that should# be running under this group. This value must be non-negative and defaults# to 1.count = 3 运行 nomad job 命令可以看到如果我们更新了 job 会发生什么变化 123456789101112131415161718# nomad job plan example.nomad+/- Job: &quot;example&quot;+/- Task Group: &quot;cache&quot; (2 create, 1 in-place update) +/- Count: &quot;1&quot; =&gt; &quot;3&quot; (forces create) Task: &quot;redis&quot;Scheduler dry-run:- All tasks successfully allocated.Job Modify Index: 9To submit the job with version verification run:nomad job run -check-index 9 example.nomadWhen running the job with the check-index flag, the job will only be run if theserver side version matches the job modify index returned. If the index haschanged, another user has modified the job and the plan&apos;s results arepotentially invalid. 使用给出的更新命令去更新 job 123456789# nomad job run -check-index 9 example.nomad==&gt; Monitoring evaluation &quot;153899d5&quot; Evaluation triggered by job &quot;example&quot; Evaluation within deployment: &quot;d1734e35&quot; Allocation &quot;fd9851d0&quot; created: node &quot;53f694be&quot;, group &quot;cache&quot; Allocation &quot;05e3f77a&quot; modified: node &quot;53f694be&quot;, group &quot;cache&quot; Allocation &quot;e6ca8a97&quot; created: node &quot;53f694be&quot;, group &quot;cache&quot; Evaluation status changed: &quot;pending&quot; -&gt; &quot;complete&quot;==&gt; Evaluation &quot;153899d5&quot; finished with status &quot;complete&quot; 停止 job停止 job 使用 nomad stop 命令 123456# nomad stop example==&gt; Monitoring evaluation &quot;ffc6fddd&quot; Evaluation triggered by job &quot;example&quot; Evaluation within deployment: &quot;d1734e35&quot; Evaluation status changed: &quot;pending&quot; -&gt; &quot;complete&quot;==&gt; Evaluation &quot;ffc6fddd&quot; finished with status &quot;complete&quot; 停止后，使用 nomad status 命令查看 Job 状态已经变为 dead 状态 123[root@localhost nomad_cluster]# nomad job statusID Type Priority Status Submit Dateexample service 50 dead (stopped) 2018-06-13T19:49:41+08:00 搭建集群现在开始我们搭建一个 nomad 集群，前边我们使用 dev 模式同时启动了一个 nomad server 以及 client 端，如果在生产环境，建议至少使用 3-5 台服务 环境准备我这里准备三台虚拟机 ip 虚拟名 10.211.55.4 s1 10.211.55.5 s2 10.211.55.6 s3 以下简称 s1,s2,s3 启动 server在 s1 虚机上工作目录创建服务器配置文件 server.hcl，内容如下: 12345678910111213# touch server.hcl# vi server.hcldata_dir = &quot;/tmp/server&quot;name = &quot;server1&quot;server &#123; enabled = true # Self-elect, should be 3 or 5 for production bootstrap_expect = 3&#125; 保存，退出，启动 nomad server 代理 123456789101112131415161718192021222324# nomad agent -config server.hcl==&gt; Loaded configuration from server.hcl==&gt; Starting Nomad agent...==&gt; Nomad agent configuration: Client: false Log Level: INFO Region: global (DC: dc1) Server: true Version: 0.8.1==&gt; Nomad agent started! Log data will stream in below: 2018/06/10 12:54:32 [INFO] raft: Initial configuration (index=0): [] 2018/06/10 12:54:32 [INFO] raft: Node at 10.211.55.4:4647 [Follower] entering Follower state (Leader: &quot;&quot;) 2018/06/10 12:54:32 [INFO] serf: EventMemberJoin: server1.global 10.211.55.4 2018/06/10 12:54:32.125891 [INFO] nomad: starting 2 scheduling worker(s) for [service batch system _core] 2018/06/10 12:54:32.126270 [INFO] nomad: adding server server1.global (Addr: 10.211.55.4:4647) (DC: dc1) 2018/06/10 12:54:32.126983 [ERR] consul: error looking up Nomad servers: server.nomad: unable to query Consul datacenters: Get http://127.0.0.1:8500/v1/catalog/datacenters: dial tcp 127.0.0.1:8500: getsockopt: connection refused 2018/06/10 12:54:33 [WARN] raft: no known peers, aborting election 2018/06/10 12:54:42.238478 [ERR] worker: failed to dequeue evaluation: No cluster leader 2018/06/10 12:54:42.647826 [ERR] worker: failed to dequeue evaluation: No cluster leader 2018/06/10 12:54:47.530410 [ERR] worker: failed to dequeue evaluation: No cluster leader 2018/06/10 12:54:47.877889 [ERR] worker: failed to dequeue evaluation: No cluster leader 这里可以看到 agent 启动之后会去找 leader，由于我们配置的 bootstrap_expect 参数为 3，因此只有三个集群节点都启动之后，才回去选举一个 leader接下来我们在 s2, s3 机器上也重复上面的操作，分别启动一个 server,为了区分，在三个配置文件中我们使用 name 区分，s1,s2,s3 配置文件中的 name 分别为 server1,server2,server 三台机器上的 agent 都启动成功之后，我们使用 nomad join 命令将三个 server 连接 1234在s2上执行# nomad server join 10.211.55.4在s3上执行# nomad server join 10.211.55.5 这样就把三个 server 组成了一个集群,并且他们已经选举了一个 leader 12345# nomad server membersName Address Port Status Leader Protocol Build Datacenter Regionserver1.global 10.211.55.4 4648 alive false 2 0.8.1 dc1 globalserver2.global 10.211.55.5 4648 alive true 2 0.8.1 dc1 globalserver3.global 10.211.55.6 4648 alive false 2 0.8.1 dc1 global 启动 client在 s2 虚机上工作目录创建服务器配置文件 client1.hcl，内容如下: 12345678910111213141516171819202122# touch client1.hcl# vi client1.hcllog_level = &quot;DEBUG&quot;data_dir = &quot;/tmp/client1&quot;name = &quot;client1&quot;client &#123; enabled = true # For demo assume we are talking to server1. For production, # this should be like &quot;nomad.service.consul:4647&quot; and a system # like Consul used for service discovery. servers = [&quot;10.211.55.5:4647&quot;]&#125;# Modify our port to avoid a collision with server1 and client1ports &#123; http = 5656&#125; 保存，退出，启动 nomad client 代理 1234567891011121314151617181920212223[root@localhost nomad_cluster]# nomad agent -config client1.hcl==&gt; Loaded configuration from client1.hcl==&gt; Starting Nomad agent...==&gt; Nomad agent configuration: Client: true Log Level: DEBUG Region: global (DC: dc1) Server: false Version: 0.8.1==&gt; Nomad agent started! Log data will stream in below: 2018/06/13 20:43:31.353729 [INFO] client: using state directory /tmp/client1/client 2018/06/13 20:43:31.354585 [INFO] client: using alloc directory /tmp/client1/alloc 2018/06/13 20:43:31.357777 [DEBUG] client.fingerprint_manager: built-in fingerprints: [arch cgroup consul cpu host memory network nomad signal storage vault env_aws env_gce] 2018/06/13 20:43:35.446947 [DEBUG] driver.docker: image &quot;nginx&quot; (sha256:cd5239a0906a6ccf0562354852fae04bc5b52d72a2aff9a871ddb6bd57553569) reference count incremented: 1 2018/06/13 20:43:35.452540 [DEBUG] client: starting task context for &apos;redis&apos; (alloc &apos;1bcb0f46-a710-769a-287e-7d432342f143&apos;) 2018/06/13 20:43:35.453826 [DEBUG] client: starting task runners for alloc &apos;1bcb0f46-a710-769a-287e-7d432342f143&apos; 2018/06/13 20:43:40.697028 [DEBUG] client: 3 evaluations triggered by node update 2018/06/13 20:43:40.697068 [DEBUG] client: state updated to ready 2018/06/13 20:43:40.869207 [DEBUG] client: state changed, updating node and re-registering. 2018/06/13 20:43:40.878128 [INFO] client: node registration complete 重复上面的操作在 s3 上面也启动一个 client 端，使用一下命令查看节点 1234# nomad node-statusID DC Name Class Drain Eligibility Status85be1fd0 dc1 client1 &lt;none&gt; false eligible readyd3f05cb0 dc1 client2 &lt;none&gt; false eligible ready 现在我们已经有了一个集群，我们在 s1 上提交一个 job 测试一下我们的集群，使用 example.nomad，确保 count=3 12345678910# nomad job run example.nomad==&gt; Monitoring evaluation &quot;8095c3ec&quot; Evaluation triggered by job &quot;example&quot; Allocation &quot;7bc737e3&quot; created: node &quot;85be1fd0&quot;, group &quot;cache&quot; Allocation &quot;22e53fa4&quot; created: node &quot;1a9b1e3d&quot;, group &quot;cache&quot; Allocation &quot;2692e18b&quot; created: node &quot;1a9b1e3d&quot;, group &quot;cache&quot; Evaluation within deployment: &quot;b44335b4&quot; Allocation &quot;7bc737e3&quot; status changed: &quot;pending&quot; -&gt; &quot;running&quot; Evaluation status changed: &quot;pending&quot; -&gt; &quot;complete&quot;==&gt; Evaluation &quot;8095c3ec&quot; finished with status &quot;complete&quot; 输出中看到调度程序为其中一个客户机节点分配了两个任务，剩下的任务分配给第二个客户端。也可以使用 nomad status 命令查看 12345678910111213141516171819202122232425262728293031323334353637[root@centos-linux nomad_cluster]# nomad job statusID Type Priority Status Submit Dateexample service 50 running 2018-06-13T20:57:26+08:00example-api-3 service 50 dead (stopped) 2018-06-12T23:16:09+08:00example-api-4 service 50 running 2018-06-12T23:18:55+08:00example-api-5 service 50 dead (stopped) 2018-06-12T23:36:26+08:00example-api-6 service 50 dead (stopped) 2018-06-13T00:55:06+08:00nginx service 50 dead (stopped) 2018-06-10T00:04:52+08:00[root@centos-linux nomad_cluster]# nomad job status exampleID = exampleName = exampleSubmit Date = 2018-06-13T20:57:26+08:00Type = servicePriority = 50Datacenters = dc1Status = runningPeriodic = falseParameterized = falseSummaryTask Group Queued Starting Running Failed Complete Lostcache 0 0 3 0 3 0Latest DeploymentID = b44335b4Status = failedDescription = Failed due to unhealthy allocationsDeployedTask Group Desired Placed Healthy Unhealthycache 3 3 0 3AllocationsID Node ID Task Group Version Desired Status Created Modified22e53fa4 1a9b1e3d cache 2 run running 3d7h from now 3d7h from now2692e18b 1a9b1e3d cache 2 run running 3d7h from now 3d7h from now7bc737e3 85be1fd0 cache 2 run running 3d7h from now 3d7h from now 到此，我们已经成功搭建了 nomad 集群，并在集群上运行了简单地 Job!]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>nomad</tag>
        <tag>分布式，微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解node的Event Loop]]></title>
    <url>%2F2018%2F05%2F06%2F1525596645000%2F</url>
    <content type="text"><![CDATA[Event Loop 的六个阶段timers 调用setTimeout(),setInterval()的回调 Timers的回调函数在他指定的时间之后运行，因为他必须等待同步代码执行完毕，并且时间循环可能会被阻塞到poll阶段另外系统的调度和其他回调的执行也有可能延迟他的执行 pending callbacks 调用系统的错误回调 idle, prepare 只在内部使用，不考虑 poll 取新的I/O事件执行I/O相关的回调（除关闭回调、定时器的回调、setImmediate()的回调） 如果event loop进入了poll阶段，并且没有定时器，将会出现一下两种情况 如果poll队列不为空，event loop将遍历poll队列里面的所有回调函数以同步方式去执行，知道队列耗尽，或者达到系统的限制 如果poll队列为空，将会出现两种情况 执行脚本中存在setImmediate(),event loop将结束poll阶段，到下一个check阶段去执行setImmediate()的回调 如果脚本中没有setImmediate() event loop将一直等待回调被添加到poll队列，并且立即去执行他 一旦poll阶段为空，event loop 将会去检查已经到时间的定时器，如果有准备好的定时器，event loop将会返回到timers阶段去执行定时器的回调event loop将在此阶段等待传入的链接，请求等 check 调用setImmediate()回调 setImmediate()是一个特殊的定时器，处在event loop的一个单独阶段，poll阶段完成之后立即执行 close callbacks 一些关闭回调，比如 socket.on(‘close’, …) Node四个定时器为了协调异步任务，Node 提供了四个定时器，让任务可以在指定的时间运行。 setTimeout() setInterval() setImmediate() process.nextTick() 猜测一下以下代码的运行结果12345setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));(() =&gt; console.log(5))(); 运行结果如下。1234553412 同步代码先于异步代码执行 异步任务分为： 追加在本轮循环的异步代码 追加在次轮循环的异步代码 1234567// 下面两行，次轮循环执行 等待时间相同的情况下setTimeout先于setInterval执行setTimeout(() =&gt; console.log(1));setInterval(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));// 下面两行，本轮循环执行process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4)); setTimeout()次轮循环中执行 setTimeout()在timers阶段执行，只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。 setImmediate()次轮循环中执行 setImmediate()在check阶段执行，主线程和事件队列的函数执行完成之后立即执行setImmediate指定的回调函数，和setTimeout(fn,0)的效果差不多当setImmediate()与setTimeout()在同一个主模块中运行而不是一个I/O循环中的时候，受到进程性能的影响，他们的执行顺序是不定的，如下例：1234567891011121314151617// timeout_vs_immediate.jssetTimeout(() =&gt; &#123; console.log('timeout');&#125;, 0);setImmediate(() =&gt; &#123; console.log('immediate');&#125;);$ node timeout_vs_immediate.jstimeoutimmediate$ node timeout_vs_immediate.jsimmediatetimeout 如果他们处在一个I/O循环里面，则总是setImmediate()先执行，如下例：123456789101112// timeout_vs_immediate.jsconst fs = require('fs');fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout'); &#125;, 0); //总是setImmediate()先执行 setImmediate(() =&gt; &#123; console.log('immediate'); &#125;);&#125;); process.nextTick()本轮循环中执行不在event loop中，不属于任何一个阶段同步代码执行完之后立即执行，所有异步里面最快的 process.nextTick()方法可以在当前”执行栈”的尾部–&gt;下一次Event Loop（主线程读取”任务队列”）之前–&gt;触发process指定的回调函数。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。（nextTick虽然也会异步执行，但是不会给其他io事件执行的任何机会） 最后process.maxTickDepth()的缺省值是1000，如果超过会报exceed callback stack。官方认为在递归中用process.nextTick会造成饥饿event loop，因为nextTick没有给其他异步事件执行的机会，递归中推荐用setImmediate Promise的执行Promise的执行时在一个微任务队列中，process.nextTick()执行之后立即执行]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>setTimeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装配置Nginx]]></title>
    <url>%2F2018%2F04%2F15%2F1523786887000%2F</url>
    <content type="text"><![CDATA[安装 安装nginx依赖包 123yum install opensslyum install zlibyum install pcre Nginx依赖项 1rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装nginx 1yum install nginx 启动nginx 123service start nginx或者systemctl start nginx 配置主配置文件：/etc/nginx/conf.d/nginx.conf在主配置的include处可以修改自己的配置文件路径 12345678910111213141516171819202122232425262728293031323334user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; #include /etc/nginx/conf.d/*.conf; // 默认配置文件位置; include /root/nginx/conf/*.conf; // 修改为自己的路径;&#125;]]></content>
      <tags>
        <tag>linux</tag>
        <tag>nginx</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建node的GraphQL服务端]]></title>
    <url>%2F2018%2F04%2F15%2F1523775006000%2F</url>
    <content type="text"><![CDATA[GraphQL和传统的REST API相比查询更加灵活，GraphQL 简单来说就是：取哪些数据是由client来决定，GraphQL 中，client 直接对 server说想要什么数据，server负责精确的返回目标数据，以nodejs为例搭建一个简单地服务端。 GraphQL工作的大致流程 描述你的数据 12345type Project &#123; name: String tagline: String contributors: [User]&#125; 请求你所要的数据 12345&#123; project(name: &quot;GraphQL&quot;) &#123; tagline &#125;&#125; 得到可预测的结果 12345&#123; &quot;project&quot;: &#123; &quot;tagline&quot;: &quot;A query language for APIs&quot; &#125;&#125; 需求分析设计用户可以发表作品，可以对其他用户发表的作品投票 使用apollo-server-express初始化一个服务创建目录初始化项目123mkdir graphql_node_democd graphql_node_demonpm init 安装依赖1npm i express body-parser apollo-server-express graphql graphql-tools --save 在根目录下创建启动文件index.js1234567891011121314151617181920212223242526272829const express = require('express');const bodyParser = require('body-parser');const &#123; graphqlExpress, graphiqlExpress &#125; = require('apollo-server-express');const &#123; createServer &#125; = require('http');const PORT = process.env.PORT || 3000;const NODE_ENV = process.env.NODE_ENV || 'development'const start = async () =&gt; &#123; var app = express(); const buildOptions = async (req, res) =&gt; &#123; return &#123; context: &#123;&#125; &#125;; &#125;; app.use('/graphql', bodyParser.json(), graphqlExpress(buildOptions)); app.use('/graphiql', graphiqlExpress(&#123; endpointURL: '/graphql', &#125;)); const server = createServer(app); server.listen(PORT, () =&gt; &#123; console.log(`fmlp.$&#123;NODE_ENV&#125; GraphQL server running on port $&#123;PORT&#125;`) &#125;);&#125;;start(); 现在可以启动服务尝试一下1node index.js 在浏览器访问http://localhost:3000/graphiql 可以看到会报错，是因为还没有添加schema 增加schema创建一个schema文件夹，并在文件夹里面抽创建两个文件，index.js、resolvers.jsindex.js里面定义我们的type，也就是描述数据，resolvers.js定义对返回数据的解析函数1234mkdir schemacd schematouch index.jstouch resolvers.js schema/index.js文件中我们定义三个type1234567891011121314151617181920const &#123;makeExecutableSchema&#125; = require('graphql-tools');const resolvers = require('./resolvers');// 在这里定义所有的类型const typeDefs = ` type Link &#123; id: ID! url: String! description: String! postedById:String! postedBy: User &#125; type Query &#123; allLinks: [Link!]! //定义了Query类型的查询，里面有一个查询所有Links,他的返回值是一个Link类型的数组 &#125; type User &#123; id: ID! name: String! email: String &#125;`; schema/resolvers.js文件中去执行查询并且返回客户端12345678910111213141516let links = [ &#123; id: 1, url: "http://url1", description: "link1", postedById:"userid1" &#125;]module.exports = &#123; Query: &#123; allLinks: (_, data) =&gt; &#123; return links &#125;, &#125;&#125;; ok 启动服务，刷新浏览器成功输入我们想要的查询 123456789//此处需要哪些字段写哪些字段&#123; allLinks &#123; id url description postedById &#125;&#125; 就可以返回123456789101112&#123; "data": &#123; "allLinks": [ &#123; "id": "1", "url": "http://url1", "description": "link1", "postedById": "userid1" &#125; ] &#125;&#125; 这就是一个简单的graphql查询另外Link中有一个字段postedBy是一个User类型，我们可以在resolvers.js中增加对Link中的User字段的解析，使Link列表可以返回每个Link是哪个用户发表的，这样实现了原始的关联查询在resolvers.js中增加以下代码：12345678910Link: &#123; postedBy: (&#123; postedById &#125;, data) =&gt; &#123; //此处需要根绝postedById查询数据库返回对用的user return &#123; id: postedById, name: "zhangsan", email: "zhangsan@11.com" &#125; &#125; &#125;, 由于我们没有对接真实的数据库，所以此处省略数据库查询的过程刷新浏览器现在的查询就可以是这样的12345678910111213&#123; allLinks &#123; id url description postedById postedBy&#123; id name email &#125; &#125;&#125; 返回值也变化了1234567891011121314151617&#123; "data": &#123; "allLinks": [ &#123; "id": "1", "url": "http://url1", "description": "link1", "postedById": "userid1", "postedBy": &#123; "id": "userid1", "name": "zhangsan", "email": "zhangsan@11.com" &#125; &#125; ] &#125;&#125; 这里只是实现了简单地查询操作，另外还有一些创建编辑删除的操作是需要用到Mutation类型来实现，具体不写出来，直接看github源码https://github.com/danwbj/graphql-server-apollo.git]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux环境下安装node]]></title>
    <url>%2F2018%2F04%2F14%2F1523677149000%2F</url>
    <content type="text"><![CDATA[下载1wget https://npm.taobao.org/mirrors/node/v8.9.3/node-v8.9.3-linux-x64.tar.xz 解压解压后的文件需要保留，压缩文件可以删除1tar -xzvf node-v8.9.3-linux-x64.tar.gz 创建软连接12ln -s /node-v8.9.3-linux-x64/bin/node /usr/local/bin/nodeln -s /node-v8.9.3-linux-x64/bin/npm/usr/local/bin/npm 测试安装是否成功12node -v 出现版本号即安装成功npm -v 出现版本号即安装成功 ok!]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令整理]]></title>
    <url>%2F2018%2F04%2F10%2F1523341302000%2F</url>
    <content type="text"></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker常用命令整理]]></title>
    <url>%2F2018%2F03%2F16%2F1521180935000%2F</url>
    <content type="text"><![CDATA[docker信息12345# 查看docker版本$ docker version# 查看docker系统信息$ docker info 镜像123456789101112131415161718192021222324252627# 查看镜像列表$ docker images# 删除镜像$ docker rmi name/id# 基于Dockerfile文件build镜像$ docker build [options] 镜像名 . 注意： .代表Dockerfile文件在当前路径 -t 为容器重新分配一个伪终端# 创建一个新的容器并跑一个镜像docker run [options] image -i 以交互模式运行 -t 为容器重新分配一个伪终端 -d 运行到后台 -p 80:80 端口映射 --name xxx 为容器指定一个名称 --restart=always 当容器退出时重新启动,默认为"no"# 保存images为一个tar文件$ docker save image_name -o name.tar或者$ docker save image_name &gt; name.tar#从一个tar文件加载images$ docker load &lt; name.tar 容器12345678910111213141516# 显示正在运行的容器$ docker ps -a 显示所有容器，包含不是运行中的容器# 停止运行中的容器$ docker stop 容器name/id#删除容器$ docker rm 容器name/id#进入到某个容器中$ docker exec -it 容器name/id /bin/bash #通过差异性创建一个新的image$ docker commit 容器id 新的镜像名eg: docker commit bf2eff778794 dandanwu/testimage:v2 Dockerfile编写DockerFile分为四部分组成：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令123456789101112131415161718192021222324252627282930313233343536373839404142#第一行必须指令基于的基础镜像FROM ubutu#维护者信息MAINTAINER docker_user docker_user@mail.com#使用哪个用户跑container USER#将文件&lt;src&gt;拷贝到container的文件系统对应的路径&lt;dest&gt;COPY file.js /home/file.js#将文件&lt;src&gt;拷贝到container的文件系统对应的路径&lt;dest&gt;ADD file.js /home/file.js#在终端中执行命令RUN apt-get update &amp;&amp; apt-get install -y ngnix RUN echo "\ndaemon off;"&gt;&gt;/etc/ngnix/nignix.conf#container内部服务开启的端口，主机上要用还得在启动container时，做host-container的端口映射EXPOSE 8017#设置环境变量ENV#切换目录用，可以多次切换(相当于cd命令)，对RUN,CMD,ENTRYPOINT生效WORKDIR ../#可以将本地文件夹或者其他container的文件夹挂载到container中。VOLUME#容器启动时执行指令#一个Dockerfile中只能有一条CMD命令，多条则只执行最后一条CMD#可替换性：当docker run command的命令匹配到CMD command时，会替换CMD执行的命令。CMD /usr/sbin/ngnix#需要执行多条命令的时候可以像下边这样写CMD [ "cmd1", "cmd2", "cmd3" ]#container启动时执行的命令，但是一个Dockerfile中只能有一条ENTRYPOINT命令，如果多条，则只执行最后一条#ENTRYPOINT没有CMD的可替换特性ENTRYPOINT /usr/sbin/ngnix]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js对象引用赋值引发数据可变的解决方案]]></title>
    <url>%2F2018%2F03%2F01%2F1519871336011%2F</url>
    <content type="text"><![CDATA[js赋值（引用赋值）12345678910111213141516171819const student1 = &#123; school: 'Baidu', name: 'HOU Ce', birthdate: '1995-12-15',&#125;const changeStudent = (student, newName, newBday) =&gt; &#123; const newStudent = student; newStudent.name = newName; newStudent.birthdate = newBday; return newStudent;&#125;const student2 = changeStudent(student1, 'YAN Haijing', '1990-11-10');// both students will have the name propertiesconsole.log(student1, student2);// Object &#123;school: "Baidu", name: "YAN Haijing", birthdate: "1990-11-10"&#125; // Object &#123;school: "Baidu", name: "YAN Haijing", birthdate: "1990-11-10"&#125; 创建了一个新的对象student2，但是老的对象student1也被改动了 深拷贝与浅拷贝的区别以Object.assign(浅拷贝)为列：123456var obj1 = &#123; a: 0, b: &#123; c: 0 &#125; &#125;var obj2 = Object.assign(&#123;&#125;, obj1)obj2.a = 1obj2.b.c = 1console.log(obj1) //&#123; a: 0, b: &#123; c: 1 &#125; &#125;console.log(obj2) //&#123; a: 1, b: &#123; c: 1 &#125; 为什么改变属性a不是指向同一个引用，而b.c指向了同一个引用?因为b不是简单地数据类型，Object.assign拷贝的时候是浅拷贝，只复制了{ c: 0 }的引用变量b,而a:1是简单类型，拷贝的时候拷贝的是值，所以当obj2.b.c改变的时候，因为obj1.b和obj2.b指向的是同一个内存地址，所以obj1.b.c的值也发生了改变。如果是深拷贝obj1.b.c的值就不会因为obj2.b.c改变而改变 解决方案（创建不可变数据）使用ES6当中的解构赋值(浅拷贝，而不是深拷贝)1234567891011121314const changeStudent = (student, newName, newBday) =&gt; &#123; return &#123; ...student, // 使用解构 name: newName, // 覆盖name属性 birthdate: newBday // 覆盖birthdate属性 &#125;&#125;const student2 = changeStudent(student1, 'YAN Haijing', '1990-11-10');// both students will have the name propertiesconsole.log(student1, student2);// Object &#123;school: "Baidu", name: "HOU Ce", birthdate: "1995-12-15"&#125; // Object &#123;school: "Baidu", name: "YAN Haijing", birthdate: "1990-11-10"&#125; Objects.assign(浅拷贝，而不是深拷贝)12345const changeStudent = (student, newName, newBday) =&gt; Object.assign(&#123;&#125;, student, &#123;name: newName, birthdate: newBday&#125;)const student2 = changeStudent(student1, 'YAN Haijing', '1990-11-10');console.log(student1, student2); 使用第三方库 比如lodash中的merge函数 注意：对于数组来说，它里面的 .map, .filter或者.reduce函数不会改变原数组，而是产生并返回一个新数组。这和纯函数的思想不谋而合。 原文连接：https://juejin.im/post/58d0ff6f1b69e6006b8fd4e9]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>引用赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript的变量函数提升总结]]></title>
    <url>%2F2018%2F03%2F01%2F1519871336000%2F</url>
    <content type="text"><![CDATA[首先对比三段代码：12var v='Hello World';alert(v); //Hello World 1234var v='Hello World';(function()&#123; alert(v);&#125;)()//Hello World 12345var v='Hello World';(function()&#123; alert(v); var v='I love you';&#125;)()//undefined javascript作用域JavaScript是函数级作用域(function-level scope)，并没有块级作用域,因此在代码块中并不会创建一个新的作用域。只有函数才会创建新的作用域，这样块里面的变量会影响到外部作用域，比如if语句：1234567var x = 1;console.log(x); // 1if (true) &#123; var x = 2; console.log(x); //2&#125; console.log(x);// 2 解决方案：在函数中创建一个临时的作用域，请像下面这样做12345678910function foo() &#123; var x = 1; if (x) &#123; (function () &#123; var x = 2; // some other code &#125;()); &#125; // x is still 1.&#125; 变量提升变量提升 只是提升变量的声明，并不会把赋值也提升上来。我们定义三个变量： 12345(function()&#123; var a='One'; var b='Two'; var c='Three';&#125;)() 实际上它是这样子的：123456(function()&#123; var a,b,c; a='One'; b='Two'; c='Three';&#125;)() 函数提升js中函数的定义有两种，函数声明方式和函数表达式方式，需要注意的是只有函数声明会被提升 函数声明方式提升【成功】 1234567function myTest()&#123; foo(); function foo()&#123; alert("我来自 foo"); &#125;&#125;myTest(); 函数表达式方式提升【失败】 1234567function myTest()&#123; foo(); var foo =function foo()&#123; alert("我来自 foo"); &#125;&#125;myTest(); 原文：http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>变量函数提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统分类]]></title>
    <url>%2F2018%2F02%2F27%2F1519718854000%2F</url>
    <content type="text"><![CDATA[一般来说著名的linux系统基本上分两大类： RedHat系列：Redhat、Centos、Fedora等 Debian系列：Debian、Ubuntu等 RedHat系列常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数” 包管理工具 yum 123456789yum的配置文件：/etc/yum.conf yum install gcc [centos] 更新：yum update 安装：yum install xxx 移除：yum remove xxx 清除已经安装过的档案（/var/cache/yum/）：yum clean all 搜寻：yum search xxx 列出所有档案：yum list 查询档案讯息：yum info xxx 支持tar包 Debian系列常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数” 包管理工具 apt-get 1234更新软件包：apt-get update安装：apt-get install xxx移除：apt-get remove xxx更新安装过的包：apt-get upgrade xxx 支持tar包]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6基础]]></title>
    <url>%2F2018%2F02%2F26%2F1519612274000%2F</url>
    <content type="text"><![CDATA[let命令let有块级作用域，let声明的变量只在它所在的代码块有效 var有变量提升现象，let没有变量提升 let暂时性死区123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错let不允许重复声明一道面试题：1234567var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i) &#125;)&#125;funcs.forEach(function(func) &#123; func()&#125;) 以上代码会输出10次数组10，如果想要输出0-9，两种解决方案：123456789101112131415// ES5告诉我们可以利用闭包解决这个问题var funcs = []for (var i = 0; i &lt; 10; i++) &#123; func.push((function(value) &#123; return function() &#123; console.log(value) &#125; &#125;(i)))&#125;// es6for (let i = 0; i &lt; 10; i++) &#123; func.push(function() &#123; console.log(i) &#125;)&#125; 模板字符串字符串拼接 123456//es5 var name = 'lux'console.log('hello' + name)//es6const name = 'lux'console.log(`hello $&#123;name&#125;`) //hello lux es6提供的常用的字符串方法 1234567// includes：判断是否包含然后直接返回布尔值let str = 'hahay'console.log(str.includes('y')) // true// repeat: 获取字符串重复n次let s = 'he'console.log(s.repeat(3)) // 'hehehe' 函数默认参数1234567891011121314//es5设置参数默认值//这种方式如果num=0就会出现num的值被默认200覆盖 function action(num) &#123; num = num || 200 //当传入num时，num为传入的值 //当没传入参数时，num即有了默认值200 return num &#125;//es6设置默认参数 function action(num = 200) &#123; console.log(num) &#125; action() //200 action(300) //300 箭头函数 三个特点: 不需要function关键字来创建函数 省略return关键字 继承当前上下文的 this 关键字 1234567//例如： [1,2,3].map( x =&gt; x + 1 ) //等同于： [1,2,3].map((function(x)&#123; return x + 1 &#125;).bind(this)) 拓展的对象功能对象初始化简写12345678let name = 'danw'let age = 27var d = &#123;name:name,age:age&#125;//以上代码es6可以简写为：let name = 'danw'let age = 27var d = &#123;name,age&#125; 对象初始化中方法赋值的简写12345678910111213const people = &#123; name: 'lux', getName: function() &#123; console.log(this.name) &#125;&#125;//以上代码简写如下：const people = &#123; name: 'lux', getName () &#123; console.log(this.name) &#125;&#125; Object.assign()实现对象浅复制12345var objA = &#123;a：1,b:2&#125;const obj = Object.assign(&#123;&#125;, objA)obj.c = 3console.log(obj) //&#123;a：1,b:2,c:3&#125;console.log(objA) //&#123;a：1,b:2&#125; objA的值不会被改变 更方便的数据访问–解构12345678910111213const people = &#123; name: 'lux', age: 20&#125;const name = people.nameconst age = people.ageconsole.log(name + ' --- ' + age)//对象解构取值const &#123;name,age&#125; = people//数组结构取值const color = ['red', 'blue']const [first, second] = color Spread Operator 展开运算符（…）123456789//数组const color = ['red', 'yellow']const colorful = [...color, 'green', 'pink']console.log(colorful) //[red, yellow, green, pink]//对象const alp = &#123; fist: 'a', second: 'b'&#125;const alphabets = &#123; ...alp, third: 'c' &#125;console.log(alphabets) //&#123; "fist": "a", "second": "b", "third": "c" import 和 export用法总结 当用export default people导出时，就用 import people 导入（不带大括号） 一个文件里，有且只能有一个export default。但可以有多个export。 当用export name 时，就用import { name }导入（记得带上大括号） 当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, { name, age } 当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example Promise思考题1234567891011121314setTimeout(function() &#123; console.log(1) &#125;, 0); new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3); &#125;).then(function() &#123; console.log(4); &#125;); console.log(5);//输出：2 3 5 4 1 类似面试题：https://zhuanlan.zhihu.com/p/25407758]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript的GC理解]]></title>
    <url>%2F2018%2F02%2F24%2F1519459656000%2F</url>
    <content type="text"><![CDATA[js会将我们使用不到的变量销毁，怎么判断哪些变量是不会再使用的 全局变量是不会被销毁的，因为我们随时都可能会用到这个变量，所以不能被销毁。 函数内部的变量再函数执行完之后就会被销毁，但是如果这个函数有被外部的变量引用就不会销毁12345678910function a()&#123; var b = 0; return function()&#123; b ++; console.log(b); &#125;&#125;var d = a();d();//1d();//2]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call()、apply()、bind()区别]]></title>
    <url>%2F2018%2F02%2F24%2F1519456955000%2F</url>
    <content type="text"><![CDATA[执行的环境thisthis指向：this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的 apply(),call(),bind()都是改变函数执行的环境（this）的，apply(),call()改变函数的this之后会立即执行函数，而bind()返回的是被修改this之后的新函数，在需要调用的时候去调用这个新函数，并且可以在执行的执行的时候去传递参数。 12345678var a = &#123; user:"danw", fn:function ()&#123; console.log(this.user) &#125;&#125;var b = a.fnb() //undefined 上面的代码之所以返回undefined是因为b在调用的时候是window.b(),this指向的是window，如果直接执行a.fn就会返回a里面的user1234567var a = &#123; user:"danw", fn:function ()&#123; console.log(this.user) &#125;&#125;a.fn() //danw 虽然这种方式可以正确的返回，但是有时间我们不得不将对象赋值给另一个变量，这时候就需要使用以下三种方法来改变this指向： call()12345678var a = &#123; user:"danw", fn:function ()&#123; console.log(this.user) &#125;&#125;var b = a.fnb.call(a) //danw 通过call方法将b添加到a执行环境中去执行，所有this就会指向acall方法还可以传递多个参数12345678var a = &#123; user:"danw", fn:function (p1,p2)&#123; console.log(this.user) &#125;&#125;var b = a.fnb.call(a,1,2) //danw apply()apply和call方法的效果一样，唯一不同的是在传递参数的时候是按照数组传递的。12345678var a = &#123; user:"danw", fn:function (p1,p2)&#123; console.log(this.user) &#125;&#125;var b = a.fnb.apply(a,[1,2]) //danw bind()bind()方法和apply(),call()方法一样会改变this指向，但是bind()方法不会立即去执行函数12345678var a = &#123; user:"danw", fn:function ()&#123; console.log(this.user) &#125;&#125;var b = a.fnb.bind(a) 执行上面代码发现并没有打印出结果，是因为b.bind(a)会返回一个新的函数123456789var a = &#123; user:"danw", fn:function ()&#123; console.log(this.user) &#125;&#125;var b = a.fnvar c = b.bind(a) //返回新的函数cc() //danw 执行函数c,会返回danw 所以谁bind()可以让对应的函数想什么时候执行就什么时候执行bind()也可以传递参数,并且可以在执行的时候再次追加参数12345678910var a = &#123; user:"danw", fn:function (p1,p2,p3)&#123; console.log(p1,p2,p3) //1,2,3 console.log(this.user) &#125;&#125;var b = a.fnvar c = b.bind(a,1) //返回新的函数cc(2,3) //danw 执行函数c,会返回danw]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>call()</tag>
        <tag>apply()</tag>
        <tag>bind()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise深入理解]]></title>
    <url>%2F2018%2F02%2F12%2F1518415297000%2F</url>
    <content type="text"><![CDATA[promise是什么promise 是一个构造函数，自己身上有all、reject、resolve这些方法，原型上有then、catch这些方法，用Promise new出来的对象肯定就有then、catch方法。1234567var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('执行完成'); resolve('随便什么数据'); &#125;, 2000);&#125;); *注意，这里知识new了一个Promise对象，并没有去调用它，但是传进去的函数已经之行了，所以在使用Promise的时候一般是包在一个函数中，使用的时候再去调用函数。 promise链式操作调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function runAsync1()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('runAsync1执行完成'); resolve('runAsync1随便什么数据'); &#125;, 2000); &#125;);&#125;function runAsync2()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('runAsync2执行完成'); resolve('runAsync2随便什么数据'); &#125;, 2000); &#125;);&#125;function runAsync3()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('runAsync3执行完成'); resolve('runAsync3随便什么数据'); &#125;, 2000); &#125;);&#125;runAsync1().then(data =&gt; &#123; console.log(data)//runAsync1函数的resolve结果 return runAsync2()&#125;).then(data =&gt; &#123; console.log(data)//runAsync2函数的resolve结果 return runAsync3()&#125;).then(data =&gt; &#123; console.log(data) //runAsync3函数的resolve结果 &#125;)//如果当前函数执行不依赖于上一个函数的返回值，也可以这样写:runAsync1().then(runAsync2).then(runAsync3).then(data =&gt; &#123; console.log(data) //这里只能拿到runAsync3函数的resolve结果 &#125;)//当然这种方式也可以手动在每一个函数内部获取上一个函数的返回值，例如runAsync2想要使用runAsync1的返回值，runAsync2就得这样写：function runAsync2(data)&#123; console.log(data)//data为runAsync1函数的resolve结果 return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('runAsync2执行完成'); resolve('runAsync2随便什么数据'); &#125;, 2000); &#125;);&#125; 异常处理使用catch处理异常then方法有两个参数，第一个是处理resolve的回调，第二个是处理reject的回调，catch和then的第二个参数一样也是指定reject回调的。以上面的列子说明： 可以在then的第二个参数里面处理error 1234567891011runAsync1().then(data =&gt; &#123; console.log(data)//runAsync1函数的resolve结果 return runAsync2()&#125;).then(data =&gt; &#123; console.log(data)//runAsync2函数的resolve结果 return runAsync3()&#125;).then(data =&gt; &#123; console.log(data) //runAsync3函数的resolve结果 &#125;,err=&gt;&#123; console.log(err)&#125;) 也可以放在then方法的外面使用catch处理，效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中 1234567891011runAsync1().then(data =&gt; &#123; console.log(data) return runAsync2()&#125;).then(data =&gt; &#123; console.log(data) return runAsync3()&#125;).then(data =&gt; &#123; console.log(data) &#125;).catch(err =&gt; &#123; console.log(err)&#125;) *注意，不管runAsync1、runAsync2、runAsync3出现异常，都会走到catch中，如果runAsync1出现异常，runAsync2、runAsync3都不会执行。 Promise.all使用（谁执行的慢以谁为准执行回调，但是返回值是所有的返回值集合）并行执行一组异步操作，并且返回值是所有异步操作返回值的数组12345Promise .all([runAsync1(), runAsync2(), runAsync3()]) .then(function(results)&#123; console.log(results);&#125;); Promise.race（谁执行的快以谁为准执行回调）使用场景：可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作12345Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 示例代码：12345678910111213141516171819202122232425262728//10秒之后执行function timeout10()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; resolve('success'); &#125;, 4000); &#125;); return p;&#125;//延时函数，用于给请求计时function timeout5()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; reject('请求超时'); &#125;, 5000); &#125;); return p;&#125;Promise.race([timeout10(), timeout5()]).then(function(results)&#123; console.log(results);&#125;).catch(function(reason)&#123; console.log(reason);&#125;); 参考帖子：http://www.cnblogs.com/lvdabao/p/es6-promise-1.html]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下使用tree命令]]></title>
    <url>%2F2018%2F02%2F10%2F1518239216000%2F</url>
    <content type="text"><![CDATA[mac下默认是没有 tree命令的，不过我们可以使用find命令模拟出tree命令的效果 如显示当前目录的 tree 的命令1find . -print | sed -e &apos;s;[^/]*/;|____;g;s;____|; |;g&apos; 使用alias 指定别名，将它变成一个命令 .bash_profile文件增加以下代码： 1alias tree=&quot;find . -print | sed -e &apos;s;[^/]*/;|____;g;s;____|; |;g&apos;&quot;]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
