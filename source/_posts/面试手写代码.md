---

title: 面试手写代码整理

date: 2021-04-23 11:16:18

tags: [javascript]

category: [javascript]

---



### 防抖节流

-  防抖



  触发高频事件之后，在n秒后只执行一次，在n秒内如果再次触发，就会重新计算时间



  实现思路：在n秒内触发删除之前旧的定时器

```javascript
function debounce(fn, interval) {

     let time = null;

     return function () {

          clearInterval(this);

         time = setTimeout(() => {

              fn.apply(this, arguments);

          }, interval)

      }

  }

  

  function testfn() {

      console.log("hello");

  }

  debounce(testfn, 500);  
```



- 节流

  

  触发高频事件之后，在n秒内只执行一次



  实现思路：每次执行之前先判断是否有正在执行的定时器，定时器执行完成之后才允许再次触发执行



```javascript
function throttle(fn, interval) {

      let canRun = true;

      return function () {

          if (!canRun) return;

          canRun = false;

          setTimeout(() => {

              fn.apply(this, arguments);

              canRun = true;

          }, interval)

      }

  }

  

  function testfn() {

      console.log("hello");

  }

  throttle(testfn, 500);
```



### 拷贝

- 浅拷贝

  将内存中的某个对象复制一份，如果该对象的属性值是基本数据类型，则复制的是值，如果是复杂数据类型则复制的是地址，因此修改新对象会对原对象产生影响

  ```javascript
  function shallowClone(obj){
    let newobj = {};
    for(let key in obj){
      if(obj.hasOwnProperty(key)){
        newobj[key] = obj[key]
      }
    }
  }
  ```

- 深拷贝

  开辟一块新的空间，完整的复制一份，包括复杂类型，修改新对象不会对原对象造成任何影响

  ```javascript
  function deepClone(obj){
    if (obj === null) return null; //null 的情况
    if (obj instanceof RegExp) return new RegExp(obj); //正则表达式的情况
    if (obj instanceof Date) return new Date(obj); //日期对象的情况
    if (typeof obj != "object")return obj; 
    if (typeof obj == 'function') return new function(obj){}; //函数的情况
    //[].__proto__.constructor=Array()
    //{}.__proto__.constructor=Object()
    //因此处理数组的情况时,可以取巧用这个办法来new新对象
    let newObj = new obj.__proto__.constructor;
    for(let key in obj){
       if(obj.hasOwnProperty(key)){
          newObj[key] = deepClone(obj[key]);
       }
    } 
    return newObj;
  }
  ```

  